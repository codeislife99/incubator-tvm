From 81e4c7f50ba3118ce341220d076a575c1af2bbb1 Mon Sep 17 00:00:00 2001
From: Ritwik Das <ritwikdas54@gmail.com>
Date: Wed, 2 Dec 2020 12:27:12 -0800
Subject: [PATCH 01/36] Fix trt Test

---
 tests/python/contrib/test_tensorrt.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tests/python/contrib/test_tensorrt.py b/tests/python/contrib/test_tensorrt.py
index de982228952..47270c18e77 100644
--- a/tests/python/contrib/test_tensorrt.py
+++ b/tests/python/contrib/test_tensorrt.py
@@ -1058,7 +1058,7 @@ def test_tensorrt_dynamic_batch():
         mod = tvm.IRModule()
         mod["main"] = f
         if use_trt:
-            mod = relay.tensorrt.EnableTrt(mod)
+            mod = tensorrt.partition_for_tensorrt(mod, params)
 
         if not skip_runtime_test():
             with relay.build_config(opt_level=3):

From 8e2ce9aff1cb0232f8cc67d3451c9d37908b7883 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Wed, 2 Dec 2020 21:36:43 +0000
Subject: [PATCH 02/36] Fixed stuff

---
 tests/python/contrib/test_tensorrt.py | 26 ++++++++++++--------------
 1 file changed, 12 insertions(+), 14 deletions(-)

diff --git a/tests/python/contrib/test_tensorrt.py b/tests/python/contrib/test_tensorrt.py
index de982228952..4713130d711 100644
--- a/tests/python/contrib/test_tensorrt.py
+++ b/tests/python/contrib/test_tensorrt.py
@@ -1050,26 +1050,26 @@ def test_tensorrt_dynamic_batch():
     batches_to_test = [1, 1, 0, 2, 3, 0, 1, 3, 2]
     x_shape = (relay.Any(), 1, 8, 8)
     x_data = np.ones([max(batches_to_test)] + list(x_shape)[1:]).astype("float32")
-    result_dict = {}
     for use_trt in [True, False]:
+        result_dict = {}
         x = relay.var("x", shape=x_shape, dtype="float32")
         out = relay.nn.relu(x)
         f = relay.Function([x], out)
         mod = tvm.IRModule()
         mod["main"] = f
         if use_trt:
-            mod = relay.tensorrt.EnableTrt(mod)
+            mod, _ = tensorrt.partition_for_tensorrt(mod)
 
         if not skip_runtime_test():
             with relay.build_config(opt_level=3):
                 relay_exec = relay.create_executor("vm", mod=mod, ctx=tvm.cpu(0), target="llvm")
 
             for i, batch_size in enumerate(batches_to_test):
-                result_dict[(i, use_trt)] = relay_exec.evaluate()(x_data[:batch_size, ...])
+                result_dict[use_trt] = relay_exec.evaluate()(x_data[:batch_size, ...])
 
-    if not skip_runtime_test():
-        for i in range(len(batches_to_test)):
-            assert_result_matches(result_dict[(i, True)], result_dict[(i, False)])
+        if not skip_runtime_test():
+            for i in range(len(batches_to_test)):
+                assert_result_dict_holds(result_dict)
 
 
 def test_tensorrt_dynamic_batch_conv():
@@ -1080,8 +1080,8 @@ def test_tensorrt_dynamic_batch_conv():
     x_data = np.ones([max(batches_to_test)] + list(x_shape)[1:]).astype("float32")
     k_shape = (16, 32, 3, 3)
     params = {"kernel": np.random.uniform(-1, 1, k_shape).astype("float32")}
-    result_dict = {}
     for use_trt in [True, False]:
+        result_dict = {}
         x = relay.var("x", shape=x_shape, dtype="float32")
         kernel = relay.var("kernel", shape=k_shape, dtype="float32")
         out = relay.nn.conv2d(x, kernel, channels=16, kernel_size=(3, 3), groups=1)
@@ -1089,20 +1089,18 @@ def test_tensorrt_dynamic_batch_conv():
         mod = tvm.IRModule()
         mod["main"] = f
         if use_trt:
-            mod = tensorrt.partition_for_tensorrt(mod, params)
+            mod, _ = tensorrt.partition_for_tensorrt(mod, params)
 
         if not skip_runtime_test():
             with relay.build_config(opt_level=3):
                 relay_exec = relay.create_executor("vm", mod=mod, ctx=tvm.cpu(0), target="llvm")
 
             for i, batch_size in enumerate(batches_to_test):
-                result_dict[(i, use_trt)] = relay_exec.evaluate()(
-                    x=x_data[:batch_size, ...], **params
-                )
+                result_dict[use_trt] = relay_exec.evaluate()(x=x_data[:batch_size, ...], **params)
 
-    if not skip_runtime_test():
-        for i in range(len(batches_to_test)):
-            assert_result_matches(result_dict[(i, True)], result_dict[(i, False)])
+        if not skip_runtime_test():
+            for i in range(len(batches_to_test)):
+                assert_result_dict_holds(result_dict)
 
 
 def test_maskrcnn_resnet50() -> None:

From 4e160e986422d28ea35b390b0ec02961604815c7 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Wed, 2 Dec 2020 22:16:25 +0000
Subject: [PATCH 03/36] Done

---
 tests/python/contrib/test_tensorrt.py | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/tests/python/contrib/test_tensorrt.py b/tests/python/contrib/test_tensorrt.py
index 4713130d711..8c63c7bdb15 100644
--- a/tests/python/contrib/test_tensorrt.py
+++ b/tests/python/contrib/test_tensorrt.py
@@ -1050,8 +1050,8 @@ def test_tensorrt_dynamic_batch():
     batches_to_test = [1, 1, 0, 2, 3, 0, 1, 3, 2]
     x_shape = (relay.Any(), 1, 8, 8)
     x_data = np.ones([max(batches_to_test)] + list(x_shape)[1:]).astype("float32")
+    result_arr = [{} for _ in range(len(batches_to_test))]
     for use_trt in [True, False]:
-        result_dict = {}
         x = relay.var("x", shape=x_shape, dtype="float32")
         out = relay.nn.relu(x)
         f = relay.Function([x], out)
@@ -1065,23 +1065,23 @@ def test_tensorrt_dynamic_batch():
                 relay_exec = relay.create_executor("vm", mod=mod, ctx=tvm.cpu(0), target="llvm")
 
             for i, batch_size in enumerate(batches_to_test):
-                result_dict[use_trt] = relay_exec.evaluate()(x_data[:batch_size, ...])
+                result_arr[i][use_trt] = relay_exec.evaluate()(x_data[:batch_size, ...])
 
-        if not skip_runtime_test():
-            for i in range(len(batches_to_test)):
-                assert_result_dict_holds(result_dict)
+    if not skip_runtime_test():
+        for i in range(len(batches_to_test)):
+            assert_result_dict_holds(result_arr[i])
 
 
 def test_tensorrt_dynamic_batch_conv():
     if skip_codegen_test():
         return
-    batches_to_test = [1, 1, 0, 2, 3, 0, 1, 3, 2]
+    batches_to_test = [1, 1, 2, 3, 1, 3, 2]
     x_shape = (relay.Any(), 32, 8, 8)
     x_data = np.ones([max(batches_to_test)] + list(x_shape)[1:]).astype("float32")
     k_shape = (16, 32, 3, 3)
     params = {"kernel": np.random.uniform(-1, 1, k_shape).astype("float32")}
+    result_arr = [{} for _ in range(len(batches_to_test))]
     for use_trt in [True, False]:
-        result_dict = {}
         x = relay.var("x", shape=x_shape, dtype="float32")
         kernel = relay.var("kernel", shape=k_shape, dtype="float32")
         out = relay.nn.conv2d(x, kernel, channels=16, kernel_size=(3, 3), groups=1)
@@ -1096,11 +1096,11 @@ def test_tensorrt_dynamic_batch_conv():
                 relay_exec = relay.create_executor("vm", mod=mod, ctx=tvm.cpu(0), target="llvm")
 
             for i, batch_size in enumerate(batches_to_test):
-                result_dict[use_trt] = relay_exec.evaluate()(x=x_data[:batch_size, ...], **params)
+                result_arr[i][use_trt] = relay_exec.evaluate()(x_data[:batch_size, ...], **params)
 
-        if not skip_runtime_test():
-            for i in range(len(batches_to_test)):
-                assert_result_dict_holds(result_dict)
+    if not skip_runtime_test():
+        for i in range(len(batches_to_test)):
+            assert_result_dict_holds(result_arr[i])
 
 
 def test_maskrcnn_resnet50() -> None:

From 3104113046dd982b3bc20c3df91fb6b24442c902 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Wed, 2 Dec 2020 22:20:11 +0000
Subject: [PATCH 04/36] fix 0

---
 tests/python/contrib/test_tensorrt.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tests/python/contrib/test_tensorrt.py b/tests/python/contrib/test_tensorrt.py
index 8c63c7bdb15..aadfa130365 100644
--- a/tests/python/contrib/test_tensorrt.py
+++ b/tests/python/contrib/test_tensorrt.py
@@ -1075,7 +1075,7 @@ def test_tensorrt_dynamic_batch():
 def test_tensorrt_dynamic_batch_conv():
     if skip_codegen_test():
         return
-    batches_to_test = [1, 1, 2, 3, 1, 3, 2]
+    batches_to_test = [1, 1, 0, 2, 3, 0, 1, 3, 2]
     x_shape = (relay.Any(), 32, 8, 8)
     x_data = np.ones([max(batches_to_test)] + list(x_shape)[1:]).astype("float32")
     k_shape = (16, 32, 3, 3)

From e8b223fc37aeac06649fbefc7d567dd18e22b5c9 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Tue, 15 Dec 2020 01:29:05 +0000
Subject: [PATCH 06/36] Done

---
 3rdparty/vta-hw                            |   2 +-
 include/tvm/topi/transform.h               | 720 ++++++++++-----------
 python/tvm/relay/build_module.py           |   3 +
 python/tvm/relay/expr.py                   |   7 +
 python/tvm/relay/frontend/common.py        |   5 +
 python/tvm/relay/frontend/pytorch.py       |  81 ++-
 python/tvm/relay/loops.py                  |   6 +
 python/tvm/relay/op/_tensor.py             |   1 +
 python/tvm/relay/op/_transform.py          |  11 +
 python/tvm/relay/op/contrib/tensorrt.py    |   2 +-
 python/tvm/relay/op/strategy/generic.py    |   9 +
 python/tvm/relay/op/transform.py           |   5 +
 python/tvm/topi/__init__.py                |   2 +
 python/tvm/topi/add2.py                    |  32 +
 python/tvm/topi/generic/search.py          |  14 +
 python/tvm/topi/image/resize.py            |  34 +-
 python/tvm/topi/transform.py               |  19 +
 src/relay/op/tensor/transform.cc           |  64 +-
 src/relay/transforms/type_infer.cc         |   4 +-
 tests/python/contrib/test_street_small.jpg | Bin 0 -> 119244 bytes
 tests/python/contrib/test_tensorrt.py      |  35 +-
 tests/python/relay/test_op_level3.py       | 108 ++--
 22 files changed, 719 insertions(+), 445 deletions(-)
 create mode 100644 python/tvm/topi/add2.py
 create mode 100644 tests/python/contrib/test_street_small.jpg

diff --git a/3rdparty/vta-hw b/3rdparty/vta-hw
index 12fb486a491..87ce9acfae5 160000
--- a/3rdparty/vta-hw
+++ b/3rdparty/vta-hw
@@ -1 +1 @@
-Subproject commit 12fb486a491b75d70ec4c5e0a0cd112ab49a95bc
+Subproject commit 87ce9acfae550d1a487746e9d06c2e250076e54c
diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index c866dfb7f86..c90d7d7ac39 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -82,19 +82,18 @@ inline Tensor expand_dims(const Tensor& x, int axis, int num_newaxis = 1,
     new_shape.push_back(x->shape[i]);
   }
 
-  return compute(
-      new_shape,
-      [&](const Array<Var>& indices) {
-        Array<PrimExpr> idx;
-        for (size_t i = 0; i < static_cast<size_t>(axis); ++i) {
-          idx.push_back(indices[i]);
-        }
-        for (size_t i = axis + num_newaxis; i < indices.size(); ++i) {
-          idx.push_back(indices[i]);
-        }
-        return x(idx);
-      },
-      name, tag);
+  return compute(new_shape,
+                 [&](const Array<Var>& indices) {
+                   Array<PrimExpr> idx;
+                   for (size_t i = 0; i < static_cast<size_t>(axis); ++i) {
+                     idx.push_back(indices[i]);
+                   }
+                   for (size_t i = axis + num_newaxis; i < indices.size(); ++i) {
+                     idx.push_back(indices[i]);
+                   }
+                   return x(idx);
+                 },
+                 name, tag);
 }
 
 /*!
@@ -137,20 +136,19 @@ inline Tensor transpose(const Tensor& x, Array<Integer> axes, std::string name =
     new_shape.push_back(x->shape[new_axis]);
   }
 
-  return compute(
-      new_shape,
-      [&](const Array<Var>& indices) {
-        std::vector<PrimExpr> idx;
-        for (size_t i = 0; i < axes.size(); ++i) {
-          idx.push_back(1);
-        }
-        for (size_t i = 0; i < axes.size(); ++i) {
-          int axis = static_cast<int>(axes[i]->value);
-          idx[axis] = indices[i];
-        }
-        return x(idx);
-      },
-      name, tag);
+  return compute(new_shape,
+                 [&](const Array<Var>& indices) {
+                   std::vector<PrimExpr> idx;
+                   for (size_t i = 0; i < axes.size(); ++i) {
+                     idx.push_back(1);
+                   }
+                   for (size_t i = 0; i < axes.size(); ++i) {
+                     int axis = static_cast<int>(axes[i]->value);
+                     idx[axis] = indices[i];
+                   }
+                   return x(idx);
+                 },
+                 name, tag);
 }
 
 /*!
@@ -246,8 +244,8 @@ inline Tensor reshape(const Tensor& x, Array<PrimExpr> newshape, std::string nam
   }
 
   if (is_empty_shape(target_shape)) {
-    return compute(
-        target_shape, [&](const Array<Var>& indices) { return tvm::cast(x->dtype, 0); }, name, tag);
+    return compute(target_shape, [&](const Array<Var>& indices) { return tvm::cast(x->dtype, 0); },
+                   name, tag);
   } else {
     return compute(
         target_shape,
@@ -353,22 +351,21 @@ inline Tensor squeeze(const Tensor& x, Array<Integer> axis, bool atleast1d = fal
     out_shape.push_back(1);
   }
 
-  return compute(
-      out_shape,
-      [&](const Array<Var>& indices) {
-        Array<PrimExpr> real_indices;
-        int flag = 0;
-        for (size_t i = 0; i < ndim; ++i) {
-          if (axis_set.count(static_cast<int>(i)) == 0) {
-            real_indices.push_back(indices[i - flag]);
-          } else {
-            real_indices.push_back(0);
-            flag += 1;
-          }
-        }
-        return x(real_indices);
-      },
-      name, tag);
+  return compute(out_shape,
+                 [&](const Array<Var>& indices) {
+                   Array<PrimExpr> real_indices;
+                   int flag = 0;
+                   for (size_t i = 0; i < ndim; ++i) {
+                     if (axis_set.count(static_cast<int>(i)) == 0) {
+                       real_indices.push_back(indices[i - flag]);
+                     } else {
+                       real_indices.push_back(0);
+                       flag += 1;
+                     }
+                   }
+                   return x(real_indices);
+                 },
+                 name, tag);
 }
 
 /*!
@@ -406,28 +403,27 @@ inline Tensor concatenate(const Array<Tensor>& inputs, int axis = 0, std::string
     out_shape.push_back(i == static_cast<size_t>(axis) ? join_size : inputs[0]->shape[i]);
   }
 
-  return compute(
-      out_shape,
-      [&](const Array<Var>& indices) {
-        auto ret = inputs[0](indices);
-        auto ind = indices[axis];
-        for (size_t i = 0; i < inputs.size() - 1; ++i) {
-          ind -= axis_sizes[i];
-
-          Array<PrimExpr> idx;
-          for (size_t i = 0; i < static_cast<size_t>(axis); ++i) {
-            idx.push_back(indices[i]);
-          }
-          idx.push_back(ind);
-          for (size_t i = axis + 1; i < indices.size(); ++i) {
-            idx.push_back(indices[i]);
-          }
-
-          ret = tvm::if_then_else(ind >= 0, inputs[i + 1](idx), ret);
-        }
-        return ret;
-      },
-      name, tag);
+  return compute(out_shape,
+                 [&](const Array<Var>& indices) {
+                   auto ret = inputs[0](indices);
+                   auto ind = indices[axis];
+                   for (size_t i = 0; i < inputs.size() - 1; ++i) {
+                     ind -= axis_sizes[i];
+
+                     Array<PrimExpr> idx;
+                     for (size_t i = 0; i < static_cast<size_t>(axis); ++i) {
+                       idx.push_back(indices[i]);
+                     }
+                     idx.push_back(ind);
+                     for (size_t i = axis + 1; i < indices.size(); ++i) {
+                       idx.push_back(indices[i]);
+                     }
+
+                     ret = tvm::if_then_else(ind >= 0, inputs[i + 1](idx), ret);
+                   }
+                   return ret;
+                 },
+                 name, tag);
 }
 
 /*!
@@ -458,20 +454,19 @@ inline Tensor stack(const Array<Tensor>& inputs, int axis = 0, std::string name
   for (size_t i = static_cast<size_t>(axis); i < static_cast<size_t>(ndim); ++i)
     out_shape.push_back(inputs[0]->shape[i]);
 
-  return compute(
-      out_shape,
-      [&](const Array<Var>& indices) {
-        Array<PrimExpr> idx;
-        for (size_t i = 0; i < indices.size(); ++i)
-          if (i != static_cast<size_t>(axis)) idx.push_back(indices[i]);
-        auto ind = indices[axis];
-        auto ret = inputs[0](idx);
-        for (int i = 0; i < static_cast<int>(inputs.size() - 1); ++i) {
-          ret = tvm::if_then_else(ind == i + 1, inputs[i + 1](idx), ret);
-        }
-        return ret;
-      },
-      name, tag);
+  return compute(out_shape,
+                 [&](const Array<Var>& indices) {
+                   Array<PrimExpr> idx;
+                   for (size_t i = 0; i < indices.size(); ++i)
+                     if (i != static_cast<size_t>(axis)) idx.push_back(indices[i]);
+                   auto ind = indices[axis];
+                   auto ret = inputs[0](idx);
+                   for (int i = 0; i < static_cast<int>(inputs.size() - 1); ++i) {
+                     ret = tvm::if_then_else(ind == i + 1, inputs[i + 1](idx), ret);
+                   }
+                   return ret;
+                 },
+                 name, tag);
 }
 
 /*!
@@ -529,22 +524,21 @@ inline Array<Tensor> split(const Tensor& x, Array<PrimExpr> split_indices, int a
 
   Array<Tensor> result;
   for (size_t i = 0; i < begin_ids.size(); ++i) {
-    result.push_back(compute(
-        out_shapes[i],
-        [&](const Array<Var>& indices) {
-          auto begin = begin_ids[i];
-          Array<PrimExpr> real_indices;
-          for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
-            real_indices.push_back(indices[j]);
-          }
-          real_indices.push_back(indices[axis] + begin);
-          for (size_t j = axis + 1; j < indices.size(); ++j) {
-            real_indices.push_back(indices[j]);
-          }
-
-          return x(real_indices);
-        },
-        name, tag));
+    result.push_back(compute(out_shapes[i],
+                             [&](const Array<Var>& indices) {
+                               auto begin = begin_ids[i];
+                               Array<PrimExpr> real_indices;
+                               for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
+                                 real_indices.push_back(indices[j]);
+                               }
+                               real_indices.push_back(indices[axis] + begin);
+                               for (size_t j = axis + 1; j < indices.size(); ++j) {
+                                 real_indices.push_back(indices[j]);
+                               }
+
+                               return x(real_indices);
+                             },
+                             name, tag));
   }
 
   return result;
@@ -572,16 +566,15 @@ inline te::Tensor dynamic_strided_slice(const te::Tensor& x, const te::Tensor& b
   for (int64_t i = 0; i < src_tensor_dim; ++i) {
     out_shape.push_back(tvm::tir::Var("dim"));
   }
-  return te::compute(
-      out_shape,
-      [&](const Array<tvm::tir::Var>& indices) {
-        Array<PrimExpr> real_indices;
-        for (int32_t i = 0; i < src_tensor_dim; ++i) {
-          real_indices.push_back(indices[i] * strides(i) + begin(i));
-        }
-        return x(real_indices);
-      },
-      name, tag);
+  return te::compute(out_shape,
+                     [&](const Array<tvm::tir::Var>& indices) {
+                       Array<PrimExpr> real_indices;
+                       for (int32_t i = 0; i < src_tensor_dim; ++i) {
+                         real_indices.push_back(indices[i] * strides(i) + begin(i));
+                       }
+                       return x(real_indices);
+                     },
+                     name, tag);
 }
 
 /*!
@@ -678,16 +671,15 @@ inline Tensor strided_slice(const Tensor& x, const Array<Integer>& begin, const
     out_shape.push_back(slice_size);
   }
 
-  return compute(
-      out_shape,
-      [&](const Array<Var>& indices) {
-        Array<PrimExpr> real_indices;
-        for (size_t i = 0; i < src_tensor_dim; ++i) {
-          real_indices.push_back(indices[i] * strides_expr[i] + begin_expr[i]);
-        }
-        return x(real_indices);
-      },
-      name, tag);
+  return compute(out_shape,
+                 [&](const Array<Var>& indices) {
+                   Array<PrimExpr> real_indices;
+                   for (size_t i = 0; i < src_tensor_dim; ++i) {
+                     real_indices.push_back(indices[i] * strides_expr[i] + begin_expr[i]);
+                   }
+                   return x(real_indices);
+                 },
+                 name, tag);
 }
 
 /*!
@@ -754,13 +746,12 @@ inline Tensor take(const Tensor& a, const Tensor& indices, std::string mode = "c
   }
 
   if (mode == "clip") {
-    return compute(
-        out_shape,
-        [&](const Array<Var>& out_index) {
-          auto idx = tvm::min(tvm::max(0, indices(out_index)), a_size - 1);
-          return a(UnravelIndex(idx, a_shape));
-        },
-        name, tag);
+    return compute(out_shape,
+                   [&](const Array<Var>& out_index) {
+                     auto idx = tvm::min(tvm::max(0, indices(out_index)), a_size - 1);
+                     return a(UnravelIndex(idx, a_shape));
+                   },
+                   name, tag);
   } else if (mode == "fast") {
     LOG(WARNING) << "Fast mode segfaults when there are out-of-bounds indices. "
                     "Make sure input indices are in bound";
@@ -769,13 +760,12 @@ inline Tensor take(const Tensor& a, const Tensor& indices, std::string mode = "c
         [&](const Array<Var>& out_index) { return a(UnravelIndex(indices(out_index), a_shape)); },
         name, tag);
   } else {  // mode == "wrap"
-    return compute(
-        out_shape,
-        [&](const Array<Var>& out_index) {
-          auto idx = truncmod(truncmod(indices(out_index), a_size) + a_size, a_size);
-          return a(UnravelIndex(idx, a_shape));
-        },
-        name, tag);
+    return compute(out_shape,
+                   [&](const Array<Var>& out_index) {
+                     auto idx = truncmod(truncmod(indices(out_index), a_size) + a_size, a_size);
+                     return a(UnravelIndex(idx, a_shape));
+                   },
+                   name, tag);
   }
 }
 
@@ -799,19 +789,18 @@ inline Tensor sequence_mask(const Tensor& data, const Tensor& valid_length, doub
   auto length_dim = data->shape[axis];
   auto batch_dim = data->shape[1 - axis];
   Array<PrimExpr> out_shape = data->shape;
-  Tensor out = compute(
-      out_shape,
-      [&](const Array<Var>& out_index) {
-        Array<PrimExpr> len_index;
-        auto tid = out_index[axis];
-        auto bid = out_index[1 - axis];
-        len_index.push_back(bid);
-        PrimExpr ret =
-            tvm::if_then_else(tvm::cast(valid_length->dtype, tid) >= valid_length(len_index),
-                              tvm::tir::make_const(data->dtype, mask_value), data(out_index));
-        return ret;
-      },
-      name, tag);
+  Tensor out = compute(out_shape,
+                       [&](const Array<Var>& out_index) {
+                         Array<PrimExpr> len_index;
+                         auto tid = out_index[axis];
+                         auto bid = out_index[1 - axis];
+                         len_index.push_back(bid);
+                         PrimExpr ret = tvm::if_then_else(
+                             tvm::cast(valid_length->dtype, tid) >= valid_length(len_index),
+                             tvm::tir::make_const(data->dtype, mask_value), data(out_index));
+                         return ret;
+                       },
+                       name, tag);
   return out;
 }
 
@@ -849,66 +838,64 @@ inline Tensor take(const Tensor& a, const Tensor& indices, int axis, std::string
     }
   }
   if (mode == "clip") {
-    return compute(
-        out_shape,
-        [&](const Array<Var>& out_index) {
-          Array<PrimExpr> indices_position;
-          for (size_t j = axis; j < static_cast<size_t>(axis + indices_len); ++j) {
-            indices_position.push_back(out_index[j]);
-          }
-          Array<PrimExpr> real_indices;
-          for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
-            real_indices.push_back(out_index[j]);
-          }
-          auto idx = tvm::min(tvm::max(0, indices(indices_position)), axis_dim - 1);
-          real_indices.push_back(idx);
-          for (size_t j = axis + indices_len; j < out_index.size(); ++j) {
-            real_indices.push_back(out_index[j]);
-          }
-          return a(real_indices);
-        },
-        name, tag);
+    return compute(out_shape,
+                   [&](const Array<Var>& out_index) {
+                     Array<PrimExpr> indices_position;
+                     for (size_t j = axis; j < static_cast<size_t>(axis + indices_len); ++j) {
+                       indices_position.push_back(out_index[j]);
+                     }
+                     Array<PrimExpr> real_indices;
+                     for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
+                       real_indices.push_back(out_index[j]);
+                     }
+                     auto idx = tvm::min(tvm::max(0, indices(indices_position)), axis_dim - 1);
+                     real_indices.push_back(idx);
+                     for (size_t j = axis + indices_len; j < out_index.size(); ++j) {
+                       real_indices.push_back(out_index[j]);
+                     }
+                     return a(real_indices);
+                   },
+                   name, tag);
   } else if (mode == "fast") {
     LOG(WARNING) << "Fast mode segfaults when there are out-of-bounds indices. "
                     "Make sure input indices are in bound";
-    return compute(
-        out_shape,
-        [&](const Array<Var>& out_index) {
-          Array<PrimExpr> indices_position;
-          for (size_t j = axis; j < static_cast<size_t>(axis + indices_len); ++j) {
-            indices_position.push_back(out_index[j]);
-          }
-          Array<PrimExpr> real_indices;
-          for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
-            real_indices.push_back(out_index[j]);
-          }
-          real_indices.push_back(indices(indices_position));
-          for (size_t j = axis + indices_len; j < out_index.size(); ++j) {
-            real_indices.push_back(out_index[j]);
-          }
-          return a(real_indices);
-        },
-        name, tag);
+    return compute(out_shape,
+                   [&](const Array<Var>& out_index) {
+                     Array<PrimExpr> indices_position;
+                     for (size_t j = axis; j < static_cast<size_t>(axis + indices_len); ++j) {
+                       indices_position.push_back(out_index[j]);
+                     }
+                     Array<PrimExpr> real_indices;
+                     for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
+                       real_indices.push_back(out_index[j]);
+                     }
+                     real_indices.push_back(indices(indices_position));
+                     for (size_t j = axis + indices_len; j < out_index.size(); ++j) {
+                       real_indices.push_back(out_index[j]);
+                     }
+                     return a(real_indices);
+                   },
+                   name, tag);
   } else {  // mode == "wrap"
-    return compute(
-        out_shape,
-        [&](const Array<Var>& out_index) {
-          Array<PrimExpr> indices_position;
-          for (size_t j = axis; j < static_cast<size_t>(axis + indices_len); ++j) {
-            indices_position.push_back(out_index[j]);
-          }
-          Array<PrimExpr> real_indices;
-          for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
-            real_indices.push_back(out_index[j]);
-          }
-          auto idx = truncmod(truncmod(indices(indices_position), axis_dim) + axis_dim, axis_dim);
-          real_indices.push_back(idx);
-          for (size_t j = axis + indices_len; j < out_index.size(); ++j) {
-            real_indices.push_back(out_index[j]);
-          }
-          return a(real_indices);
-        },
-        name, tag);
+    return compute(out_shape,
+                   [&](const Array<Var>& out_index) {
+                     Array<PrimExpr> indices_position;
+                     for (size_t j = axis; j < static_cast<size_t>(axis + indices_len); ++j) {
+                       indices_position.push_back(out_index[j]);
+                     }
+                     Array<PrimExpr> real_indices;
+                     for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
+                       real_indices.push_back(out_index[j]);
+                     }
+                     auto idx = truncmod(truncmod(indices(indices_position), axis_dim) + axis_dim,
+                                         axis_dim);
+                     real_indices.push_back(idx);
+                     for (size_t j = axis + indices_len; j < out_index.size(); ++j) {
+                       real_indices.push_back(out_index[j]);
+                     }
+                     return a(real_indices);
+                   },
+                   name, tag);
   }
 }
 
@@ -984,20 +971,19 @@ inline Tensor repeat(const Tensor& x, int repeats, int axis, std::string name =
     new_shape.push_back(x->shape[i]);
   }
 
-  return compute(
-      new_shape,
-      [&](const Array<Var>& indices) {
-        Array<PrimExpr> idx;
-        for (size_t i = 0; i < static_cast<size_t>(axis); ++i) {
-          idx.push_back(indices[i]);
-        }
-        idx.push_back(indexdiv(indices[axis], repeats));
-        for (size_t i = axis + 1; i < indices.size(); ++i) {
-          idx.push_back(indices[i]);
-        }
-        return x(idx);
-      },
-      name, tag);
+  return compute(new_shape,
+                 [&](const Array<Var>& indices) {
+                   Array<PrimExpr> idx;
+                   for (size_t i = 0; i < static_cast<size_t>(axis); ++i) {
+                     idx.push_back(indices[i]);
+                   }
+                   idx.push_back(indexdiv(indices[axis], repeats));
+                   for (size_t i = axis + 1; i < indices.size(); ++i) {
+                     idx.push_back(indices[i]);
+                   }
+                   return x(idx);
+                 },
+                 name, tag);
 }
 
 /*!
@@ -1035,22 +1021,22 @@ inline Tensor tile(const Tensor& x, Array<Integer> reps, std::string name = "T_t
   for (size_t i = 0; i < tdim; ++i) new_shape.push_back(data_shape[i] * reps_shape[i]);
 
   if (is_empty_shape(new_shape)) {
-    return compute(
-        new_shape, [&](const Array<Var>& indices) { return tvm::cast(x->dtype, 0); }, name, tag);
+    return compute(new_shape, [&](const Array<Var>& indices) { return tvm::cast(x->dtype, 0); },
+                   name, tag);
   } else {
-    return compute(
-        new_shape,
-        [&](const Array<Var>& indices) {
-          Array<PrimExpr> idx;
-          if (ndim >= rdim) {
-            for (size_t i = 0; i < ndim; ++i) idx.push_back(indexmod(indices[i], x->shape[i]));
-          } else {
-            for (size_t i = 0; i < ndim; ++i)
-              idx.push_back(indexmod(indices[rdim - ndim + i], x->shape[i]));
-          }
-          return x(idx);
-        },
-        name, tag);
+    return compute(new_shape,
+                   [&](const Array<Var>& indices) {
+                     Array<PrimExpr> idx;
+                     if (ndim >= rdim) {
+                       for (size_t i = 0; i < ndim; ++i)
+                         idx.push_back(indexmod(indices[i], x->shape[i]));
+                     } else {
+                       for (size_t i = 0; i < ndim; ++i)
+                         idx.push_back(indexmod(indices[rdim - ndim + i], x->shape[i]));
+                     }
+                     return x(idx);
+                   },
+                   name, tag);
   }
 }
 
@@ -1069,25 +1055,24 @@ inline Tensor dyn_tile(const Tensor& x, Array<PrimExpr> new_shape, size_t rdim,
                        std::string name = "T_tile", std::string tag = kBroadcast) {
   size_t ndim = x->shape.size();
   if (is_empty_shape(new_shape)) {
-    return compute(
-        new_shape, [&](const Array<Var>& indices) { return tvm::cast(x->dtype, 0); }, name, tag);
+    return compute(new_shape, [&](const Array<Var>& indices) { return tvm::cast(x->dtype, 0); },
+                   name, tag);
   } else {
-    return compute(
-        new_shape,
-        [&](const Array<Var>& indices) {
-          Array<PrimExpr> idx;
-          if (ndim >= rdim) {
-            for (size_t i = 0; i < ndim; ++i) {
-              idx.push_back(indexmod(indices[i], x->shape[i]));
-            }
-          } else {
-            for (size_t i = 0; i < ndim; ++i) {
-              idx.push_back(indexmod(indices[rdim - ndim + i], x->shape[i]));
-            }
-          }
-          return x(idx);
-        },
-        name, tag);
+    return compute(new_shape,
+                   [&](const Array<Var>& indices) {
+                     Array<PrimExpr> idx;
+                     if (ndim >= rdim) {
+                       for (size_t i = 0; i < ndim; ++i) {
+                         idx.push_back(indexmod(indices[i], x->shape[i]));
+                       }
+                     } else {
+                       for (size_t i = 0; i < ndim; ++i) {
+                         idx.push_back(indexmod(indices[rdim - ndim + i], x->shape[i]));
+                       }
+                     }
+                     return x(idx);
+                   },
+                   name, tag);
   }
 }
 
@@ -1119,24 +1104,23 @@ inline Tensor gather(const Tensor& data, int axis, const Tensor& indices,
     out_shape.push_back(indices->shape[i]);
   }
 
-  return compute(
-      out_shape,
-      [&](const Array<Var>& out_index) {
-        Array<PrimExpr> indices_position;
-        for (size_t i = 0; i < ndim_i; ++i) {
-          indices_position.push_back(out_index[i]);
-        }
-        Array<PrimExpr> real_indices;
-        for (size_t i = 0; i < ndim_i; ++i) {
-          if (i == (size_t)axis) {
-            real_indices.push_back(indices(indices_position));
-          } else {
-            real_indices.push_back(indices_position[i]);
-          }
-        }
-        return data(real_indices);
-      },
-      name, tag);
+  return compute(out_shape,
+                 [&](const Array<Var>& out_index) {
+                   Array<PrimExpr> indices_position;
+                   for (size_t i = 0; i < ndim_i; ++i) {
+                     indices_position.push_back(out_index[i]);
+                   }
+                   Array<PrimExpr> real_indices;
+                   for (size_t i = 0; i < ndim_i; ++i) {
+                     if (i == (size_t)axis) {
+                       real_indices.push_back(indices(indices_position));
+                     } else {
+                       real_indices.push_back(indices_position[i]);
+                     }
+                   }
+                   return data(real_indices);
+                 },
+                 name, tag);
 }
 
 /*!
@@ -1349,18 +1333,38 @@ inline Array<Tensor> meshgrid(const Array<Tensor>& inputs, const std::string& in
   }
   Array<Tensor> result;
   for (size_t i = 0; i < inputs.size(); ++i) {
-    result.push_back(compute(
-        out_shape,
-        [&](const Array<Var>& indices) {
-          const int src_index = (cartesian_indexing && i < 2) ? 1 - i : i;
-          Array<PrimExpr> real_indices = {indices[src_index]};
-          return inputs[i](real_indices);
-        },
-        name, tag));
+    result.push_back(compute(out_shape,
+                             [&](const Array<Var>& indices) {
+                               const int src_index = (cartesian_indexing && i < 2) ? 1 - i : i;
+                               Array<PrimExpr> real_indices = {indices[src_index]};
+                               return inputs[i](real_indices);
+                             },
+                             name, tag));
   }
   return result;
 }
 
+inline Tensor add2(const Tensor& data1, const Tensor& data2, std::string name = "T_add2",
+                   std::string tag = kInjective) {
+  // Array<PrimExpr> out_shape;
+  // for (size_t i = 0; i < inputs[0]->shape.size(); ++i) {
+  //   out_shape.push_back(inputs[0]->shape[i]);
+  // }
+  // Array<Tensor> result;
+  // for (size_t i = 0; i < inputs.size(); ++i) {
+  //   result.push_back(compute(out_shape,
+  //                            [&](const Array<Var>& indices) {
+  //                              const int src_index = (cartesian_indexing && i < 2) ? 1 - i : i;
+  //                              Array<PrimExpr> real_indices = {indices[src_index]};
+  //                              return inputs[i](real_indices);
+  //                            },
+  //                            name, tag));
+  // }
+  // return result;
+  return compute(data1->shape,
+                 [&](const Array<Var>& i) { return (data1(i) + data2(i) + data1(i) + data2(i)); },
+                 name, tag);
+}
 /*!
  * \brief Transform the layout according to \p src_layout and \p dst_layout
  * \param src the source input.
@@ -1390,14 +1394,13 @@ inline Tensor layout_transform(const Tensor& src, const std::string& src_layout,
 
   Array<PrimExpr> dst_shape = layout_converter.ForwardShape(src->shape);
 
-  return compute(
-      dst_shape,
-      [&](const Array<Var>& dst_indices) {
-        Array<PrimExpr> dst_indices_expr(dst_indices.begin(), dst_indices.end());
-        Array<PrimExpr> src_indices = layout_converter.BackwardIndex(dst_indices_expr);
-        return src(src_indices);
-      },
-      name, tag);
+  return compute(dst_shape,
+                 [&](const Array<Var>& dst_indices) {
+                   Array<PrimExpr> dst_indices_expr(dst_indices.begin(), dst_indices.end());
+                   Array<PrimExpr> src_indices = layout_converter.BackwardIndex(dst_indices_expr);
+                   return src(src_indices);
+                 },
+                 name, tag);
 }
 
 /*!
@@ -1412,17 +1415,16 @@ inline Tensor shape(const Tensor& src, DataType dtype, const std::string name =
                     const std::string tag = kInjective) {
   int ndim = static_cast<int>(src->shape.size());
   Array<PrimExpr> out_shape{ndim};
-  return compute(
-      out_shape,
-      [&](const Array<Var>& indices) {
-        auto idx = indices[0];
-        PrimExpr ret = 0;
-        for (int i = 0; i < ndim; ++i) {
-          ret = tvm::if_then_else(idx == i, src->shape[i], ret);
-        }
-        return tvm::cast(dtype, ret);
-      },
-      name, tag);
+  return compute(out_shape,
+                 [&](const Array<Var>& indices) {
+                   auto idx = indices[0];
+                   PrimExpr ret = 0;
+                   for (int i = 0; i < ndim; ++i) {
+                     ret = tvm::if_then_else(idx == i, src->shape[i], ret);
+                   }
+                   return tvm::cast(dtype, ret);
+                 },
+                 name, tag);
 }
 
 /*!
@@ -1438,16 +1440,15 @@ inline Tensor ndarray_size(const Tensor& src, const DataType& dtype,
                            const std::string& tag = kInjective) {
   int ndim = static_cast<int>(src->shape.size());
   Array<PrimExpr> out_ndarray_size = {};
-  return compute(
-      out_ndarray_size,
-      [&](const Array<Var>& indices) {
-        PrimExpr ret = 1;
-        for (int i = 0; i < ndim; ++i) {
-          ret *= src->shape[i];
-        }
-        return tvm::cast(dtype, ret);
-      },
-      name, tag);
+  return compute(out_ndarray_size,
+                 [&](const Array<Var>& indices) {
+                   PrimExpr ret = 1;
+                   for (int i = 0; i < ndim; ++i) {
+                     ret *= src->shape[i];
+                   }
+                   return tvm::cast(dtype, ret);
+                 },
+                 name, tag);
 }
 
 /*!
@@ -1483,22 +1484,22 @@ inline Tensor one_hot(const Tensor& indices, const PrimExpr on_value, const Prim
 
   PrimExpr on_value_cast = cast(dtype, on_value);
   PrimExpr off_value_cast = cast(dtype, off_value);
-  return compute(
-      oshape,
-      [&](const Array<Var>& iter_vars) {
-        Array<Var> indices_indices;
-        for (size_t i = 0; i < iter_vars.size(); i++) {
-          if (static_cast<int>(i) == true_axis) {
-            continue;
-          }
-
-          indices_indices.push_back(iter_vars[i]);
-        }
-
-        auto idx = iter_vars[true_axis];
-        return tir::Select(indices(indices_indices) == idx, on_value_cast, off_value_cast);
-      },
-      name, tag);
+  return compute(oshape,
+                 [&](const Array<Var>& iter_vars) {
+                   Array<Var> indices_indices;
+                   for (size_t i = 0; i < iter_vars.size(); i++) {
+                     if (static_cast<int>(i) == true_axis) {
+                       continue;
+                     }
+
+                     indices_indices.push_back(iter_vars[i]);
+                   }
+
+                   auto idx = iter_vars[true_axis];
+                   return tir::Select(indices(indices_indices) == idx, on_value_cast,
+                                      off_value_cast);
+                 },
+                 name, tag);
 }
 
 /*!
@@ -1525,29 +1526,29 @@ inline Tensor sparse_to_dense(const Tensor& sparse_indices, const Array<PrimExpr
   for (auto l : output_shape) {
     oshape.push_back(l);
   }
-  return compute(
-      oshape,
-      [&](const Array<Var>& indices) {
-        PrimExpr ret = default_value;
-        if (0 == rank_sparse_indices) {
-          ret = if_then_else(indices[0] == sparse_indices[0], sparse_values[0], ret);
-        } else if (1 == rank_sparse_indices) {
-          for (int j = 0; j < GetConstInt(sparse_indices->shape[0]); j++) {
-            ret = if_then_else(indices[0] == sparse_indices[j], sparse_values[j], ret);
-          }
-        } else {
-          for (int j = 0; j < GetConstInt(sparse_indices->shape[0]); j++) {
-            PrimExpr aggregate_condition;
-            for (int k = 0; k < GetConstInt(sparse_indices->shape[1]); k++) {
-              PrimExpr comparision = indices[k] == sparse_indices[j][k];
-              aggregate_condition = 0 == k ? comparision : aggregate_condition && comparision;
-            }
-            ret = if_then_else(aggregate_condition, sparse_values[j], ret);
-          }
-        }
-        return ret;
-      },
-      name, tag);
+  return compute(oshape,
+                 [&](const Array<Var>& indices) {
+                   PrimExpr ret = default_value;
+                   if (0 == rank_sparse_indices) {
+                     ret = if_then_else(indices[0] == sparse_indices[0], sparse_values[0], ret);
+                   } else if (1 == rank_sparse_indices) {
+                     for (int j = 0; j < GetConstInt(sparse_indices->shape[0]); j++) {
+                       ret = if_then_else(indices[0] == sparse_indices[j], sparse_values[j], ret);
+                     }
+                   } else {
+                     for (int j = 0; j < GetConstInt(sparse_indices->shape[0]); j++) {
+                       PrimExpr aggregate_condition;
+                       for (int k = 0; k < GetConstInt(sparse_indices->shape[1]); k++) {
+                         PrimExpr comparision = indices[k] == sparse_indices[j][k];
+                         aggregate_condition =
+                             0 == k ? comparision : aggregate_condition && comparision;
+                       }
+                       ret = if_then_else(aggregate_condition, sparse_values[j], ret);
+                     }
+                   }
+                   return ret;
+                 },
+                 name, tag);
 }
 
 /*!
@@ -1668,25 +1669,24 @@ inline Tensor adv_index(const Tensor& data, const Array<Tensor>& indices,
     oshape.push_back(data->shape[i]);
   }
 
-  return compute(
-      oshape,
-      [&](const Array<Var>& iter_var) {
-        Array<PrimExpr> tensor_indices;
-        for (size_t i = 0; i < broadcast_shape.size(); ++i) {
-          tensor_indices.push_back(iter_var[i]);
-        }
-
-        Array<PrimExpr> real_indices;
-        for (size_t i = 0; i < bindices.size(); ++i) {
-          real_indices.push_back(bindices[i](tensor_indices));
-        }
-        for (size_t i = broadcast_shape.size(); i < iter_var.size(); ++i) {
-          real_indices.push_back(iter_var[i]);
-        }
-
-        return data(real_indices);
-      },
-      name, tag);
+  return compute(oshape,
+                 [&](const Array<Var>& iter_var) {
+                   Array<PrimExpr> tensor_indices;
+                   for (size_t i = 0; i < broadcast_shape.size(); ++i) {
+                     tensor_indices.push_back(iter_var[i]);
+                   }
+
+                   Array<PrimExpr> real_indices;
+                   for (size_t i = 0; i < bindices.size(); ++i) {
+                     real_indices.push_back(bindices[i](tensor_indices));
+                   }
+                   for (size_t i = broadcast_shape.size(); i < iter_var.size(); ++i) {
+                     real_indices.push_back(iter_var[i]);
+                   }
+
+                   return data(real_indices);
+                 },
+                 name, tag);
 }
 
 }  // namespace topi
diff --git a/python/tvm/relay/build_module.py b/python/tvm/relay/build_module.py
index 5dc6f81b97a..6a059c96b0c 100644
--- a/python/tvm/relay/build_module.py
+++ b/python/tvm/relay/build_module.py
@@ -244,6 +244,9 @@ def build(mod, target=None, target_host=None, params=None, mod_name="default"):
     # pylint: enable=line-too-long
     # fmt: on
     if not isinstance(mod, (IRModule, _function.Function)):
+
+        # print(f"Mod : { mod.astext(show_meta_data=False)}")
+        # print(f"Type Mod: {type(mod)}")
         raise ValueError("Type of input parameter mod must be tvm.IRModule")
 
     if isinstance(mod, _function.Function):
diff --git a/python/tvm/relay/expr.py b/python/tvm/relay/expr.py
index 7b6e4b4ccf8..200079beb65 100644
--- a/python/tvm/relay/expr.py
+++ b/python/tvm/relay/expr.py
@@ -499,6 +499,9 @@ def const(value, dtype=None):
     - bool maps to "bool"
     - other using the same default rule as numpy.
     """
+    if isinstance(value, tuple) and len(value) == 1:
+        value = value[0]
+
     if isinstance(value, (_base.numeric_types, (bool, list))):
         value = _np.array(value, dtype=dtype)
 
@@ -514,6 +517,10 @@ def const(value, dtype=None):
         value = _nd.array(value)
 
     if not isinstance(value, _nd.NDArray):
+        # import pdb
+
+        # pdb.set_trace()
+        print(f"Value : {value}, Type: {type(value)}")
         raise ValueError("value has to be scalar or NDArray")
 
     return Constant(value)
diff --git a/python/tvm/relay/frontend/common.py b/python/tvm/relay/frontend/common.py
index ae51f215540..7b6a7f1f1dc 100644
--- a/python/tvm/relay/frontend/common.py
+++ b/python/tvm/relay/frontend/common.py
@@ -269,6 +269,11 @@ def get_relay_op(op_name):
         # try search op in various modules
         for candidate in (_op, _op.nn, _op.image, _op.vision, _op.contrib):
             op = getattr(candidate, op_name, None)
+            # if op_name == "floor_mod" and op is not None:
+            #     import pdb
+
+            #     pdb.set_trace()
+            #     print(op)
             if op is not None:
                 break
     if not op:
diff --git a/python/tvm/relay/frontend/pytorch.py b/python/tvm/relay/frontend/pytorch.py
index 38478e27ff9..393a240210a 100644
--- a/python/tvm/relay/frontend/pytorch.py
+++ b/python/tvm/relay/frontend/pytorch.py
@@ -136,6 +136,12 @@ def _is_quantized_tensor(data, prelude):
 def _elemwise(name):
     def _impl(inputs, input_types):
         data0, data1 = _pytorch_promote_types(inputs[:2], input_types[:2])
+
+        # if name == "floor_mod":
+        #     x = get_relay_op(name)(data0, data1)
+        #     import pdb
+
+        #     pdb.set_trace()
         return get_relay_op(name)(data0, data1)
 
     return _impl
@@ -542,27 +548,49 @@ def _full_impl(data, fill_value, dtype):
     size = []
     need_reshape = False
     new_shape = []
-    for dim in data:
-        if isinstance(dim, _expr.Expr):
-            if isinstance(dim, _expr.Constant):
-                dim = int(dim.data.asnumpy())
+    if isinstance(data, list):
+        for dim in data:
+            if isinstance(dim, _expr.Expr):
+                if isinstance(dim, _expr.Constant):
+                    dim = int(dim.data.asnumpy())
+                    if isinstance(size, list):
+                        size.append(dim)
+                    new_shape.append(dim)
+                else:
+                    dim, success = try_infer_value(dim, lambda ret: int(ret), lambda: 0)
+                    new_shape.append(dim)
+
+                    if success:
+                        if isinstance(size, list):
+                            size.append(dim)
+                    else:
+                        size = None
+                        need_reshape = True
+            else:
                 if isinstance(size, list):
                     size.append(dim)
                 new_shape.append(dim)
+    else:
+        if isinstance(data, _expr.Expr):
+            if isinstance(data, _expr.Constant):
+                data = int(data.data.asnumpy())
+                if isinstance(size, list):
+                    size.append(data)
+                new_shape.append(data)
             else:
-                dim, success = try_infer_value(dim, lambda ret: int(ret), lambda: 0)
-                new_shape.append(dim)
+                data, success = try_infer_value(data, lambda ret: int(ret), lambda: 0)
+                new_shape.append(data)
 
                 if success:
                     if isinstance(size, list):
-                        size.append(dim)
+                        size.append(data)
                 else:
                     size = None
                     need_reshape = True
         else:
             if isinstance(size, list):
-                size.append(dim)
-            new_shape.append(dim)
+                size.append(data)
+            new_shape.append(data)
 
     if size is None:
         tmp = []
@@ -585,11 +613,11 @@ def _impl(inputs, input_types):
         if not isinstance(data, (_expr.Expr, list, torch.Tensor, np.ndarray)):
             msg = "Data type %s could not be parsed in ones op" % (type(data))
             raise AssertionError(msg)
-
         if inputs[1] is not None:
             dtype = _convert_dtype_value(inputs[1])
         else:
             dtype = default_dtype
+
         return _full_impl(data, 1, dtype)
 
     return _impl
@@ -1276,18 +1304,28 @@ def _impl_dynamic(inp, axis):
         return shape_dynamic
 
     def _impl(inputs, input_types):
+        # print(f"Inputs:{inputs[0]}, input_types {type(inputs[0])}")
         shape = _infer_shape(inputs[0], prelude.mod)
         axis = None
         if len(inputs) > 1:
             axis = int(inputs[1])
+            # print(f"AXIS = {axis}")
 
         if any(map(lambda s: isinstance(s, tvm.tir.expr.Any), shape)):
             if axis is None or isinstance(shape[axis], tvm.tir.expr.Any):
+                # print("STUPID DYNAMIC")
                 return _impl_dynamic(inputs[0], axis)
 
         if axis is not None:
+            # print("AXIS EXISTS")
             return _expr.const(shape[axis])
+        # print(f"Shape:{shape}")
         return _expr.const(shape)
+        # except:
+        #     return _expr.const(shape[0])
+        #     # import pdb
+
+        #     # pdb.set_trace()
 
     return _impl
 
@@ -1759,6 +1797,13 @@ def _impl(inputs, input_types):
     return _impl
 
 
+def _listify():
+    def _impl(inputs, input_types):
+        return list(inputs[0])
+
+    return _impl
+
+
 def _none():
     def _impl(inputs, input_types):
         return None
@@ -2202,6 +2247,19 @@ def _impl(inputs, input_types):
     return _impl
 
 
+def _remainder():
+    def _impl(inputs, input_types):
+        lhs = inputs[0]
+        rhs = inputs[1]
+        return _op.subtract(
+            lhs,
+            _op.multiply(rhs, _op.floor_divide(lhs, rhs)),
+        )
+        # return _op.floor_mod(inputs[0], inputs[1])
+
+    return _impl
+
+
 def _roi_align(prelude):
     def _impl(inputs, input_types):
         data = inputs[0]
@@ -2736,6 +2794,9 @@ def _get_convert_map(prelude, default_dtype):
         "aten::bincount": _bincount(),
         "aten::scatter_add": _scatter_add(),
         "aten::__not__": _logical_not(),
+        "aten::remainder": _elemwise("floor_mod"),
+        # "aten::remainder": _remainder(),
+        "aten::list": _listify(),
     }
     return convert_map
 
diff --git a/python/tvm/relay/loops.py b/python/tvm/relay/loops.py
index 6c2ab2e23d7..ac7271e8093 100644
--- a/python/tvm/relay/loops.py
+++ b/python/tvm/relay/loops.py
@@ -48,6 +48,7 @@ def while_loop(cond, loop_vars, loop_bodies):
     loop: relay.Expr
         The loop expression.
     """
+
     sb = ScopeBuilder()
     loop = _expr.Var("while_loop")
     fresh_vars = []
@@ -57,7 +58,12 @@ def while_loop(cond, loop_vars, loop_bodies):
         new_var = _expr.var(name, type_annotation=sb.type_of(loop_var))
         fresh_vars.append(new_var)
 
+    # import pdb
+
+    # pdb.set_trace()
+    print(f"Condition Fresh Vars = {cond(*fresh_vars)}")
     with sb.if_scope(cond(*fresh_vars)):
+
         sb.ret(loop(*loop_bodies(*fresh_vars)))
     with sb.else_scope():
         sb.ret(_expr.Tuple(fresh_vars))
diff --git a/python/tvm/relay/op/_tensor.py b/python/tvm/relay/op/_tensor.py
index 0c875045032..69f5b8edf9d 100644
--- a/python/tvm/relay/op/_tensor.py
+++ b/python/tvm/relay/op/_tensor.py
@@ -270,6 +270,7 @@ def elemwise_shape_func(attrs, inputs, _):
 register_shape_func("fast_exp", False, elemwise_shape_func)
 register_shape_func("fast_tanh", False, elemwise_shape_func)
 register_shape_func("fast_erf", False, elemwise_shape_func)
+register_shape_func("ceil", False, elemwise_shape_func)
 register_shape_func("floor", False, elemwise_shape_func)
 register_shape_func("log", False, elemwise_shape_func)
 register_shape_func("device_copy", False, elemwise_shape_func)
diff --git a/python/tvm/relay/op/_transform.py b/python/tvm/relay/op/_transform.py
index e1cb9e9d571..093eee39fca 100644
--- a/python/tvm/relay/op/_transform.py
+++ b/python/tvm/relay/op/_transform.py
@@ -63,6 +63,8 @@
 _reg.register_injective_schedule("sparse_to_dense")
 _reg.register_injective_schedule("matrix_set_diag")
 _reg.register_injective_schedule("adv_index")
+_reg.register_injective_schedule("add2")
+
 
 # concatenate
 _reg.register_schedule("concatenate", strategy.schedule_concatenate)
@@ -115,6 +117,15 @@ def compute_scatter_add(attrs, inputs, output_type):
 
 _reg.register_strategy("scatter_add", strategy.scatter_add_strategy)
 
+
+# @_reg.register_compute("add2")
+# def compute_scatter_add(attrs, inputs, output_type):
+#     """Compute definition of scatter_add"""
+#     return [topi.add2(inputs[0], inputs[1])]
+
+
+# _reg.register_schedule("add2", strategy.add2_strategy)
+
 # scatter
 @_reg.register_compute("scatter_nd")
 def compute_scatter_nd(attrs, inputs, output_type):
diff --git a/python/tvm/relay/op/contrib/tensorrt.py b/python/tvm/relay/op/contrib/tensorrt.py
index acd4f4740b2..ff1103ff72e 100644
--- a/python/tvm/relay/op/contrib/tensorrt.py
+++ b/python/tvm/relay/op/contrib/tensorrt.py
@@ -625,7 +625,7 @@ def reshape_annotate_fn(expr):  # pylint: disable=unused-variable
         if dynamic_reshape:
             # Make sure that the batch dim is unmodified.
             if int(new_shape[0]) < 0:
-                for shape_val, new_shape_val in enumerate(shape[1:], new_shape[1:]):
+                for shape_val, new_shape_val in zip(shape[1:], new_shape[1:]):
                     if not (
                         isinstance(shape_val, int)
                         and isinstance(new_shape_val, int)
diff --git a/python/tvm/relay/op/strategy/generic.py b/python/tvm/relay/op/strategy/generic.py
index ac9d3b157ec..018cd4ae980 100644
--- a/python/tvm/relay/op/strategy/generic.py
+++ b/python/tvm/relay/op/strategy/generic.py
@@ -1063,6 +1063,15 @@ def scatter_add_strategy(attrs, outs, out_type, target):
     return strategy
 
 
+# @override_native_generic_func("add2_strategy")
+# def add2_strategy(attrs, outs, out_type, target):
+#     strategy = _op.OpStrategy()
+#     strategy.add_implementation(
+#         wrap_compute_scatter(topi.add2),
+#         wrap_topi_schedule(topi.generic.schedule_add2),
+#         name="scatter_add.generic",
+#     )
+#     return strategy
 # scatter_nd
 @override_native_generic_func("scatter_nd_strategy")
 def scatter_nd_strategy(attrs, inputs, out_type, target):
diff --git a/python/tvm/relay/op/transform.py b/python/tvm/relay/op/transform.py
index 7e7f9b29959..02efc8a870f 100644
--- a/python/tvm/relay/op/transform.py
+++ b/python/tvm/relay/op/transform.py
@@ -1320,3 +1320,8 @@ def adv_index(inputs):
         Output tensor.
     """
     return _make.adv_index(Tuple(inputs))
+
+
+def add2(data1, data2):
+
+    return _make.add2(data1, data2)
\ No newline at end of file
diff --git a/python/tvm/topi/__init__.py b/python/tvm/topi/__init__.py
index 97951d941f6..f5f3f5bf187 100644
--- a/python/tvm/topi/__init__.py
+++ b/python/tvm/topi/__init__.py
@@ -39,6 +39,8 @@
 from .sort import *
 from .scatter import *
 from .scatter_add import *
+
+# from .add2 import *
 from .argwhere import *
 from . import generic
 from . import nn
diff --git a/python/tvm/topi/add2.py b/python/tvm/topi/add2.py
new file mode 100644
index 00000000000..8c5685ea687
--- /dev/null
+++ b/python/tvm/topi/add2.py
@@ -0,0 +1,32 @@
+# from tvm.te import hybrid
+
+# @hybrid.script
+# def add_2_helper(data1, data2):
+#     out = output_tensor(data1.shape, data1.dtype)
+#     out = data1 + data2
+#     return
+
+
+# def add2(data1, data2):
+#     """Update data by adding values in updates at positions defined by indices
+
+#     Parameters
+#     ----------
+#     data : relay.Expr
+#         The input data to the operator.
+
+#     indices : relay.Expr
+#         The index locations to update.
+
+#     updates : relay.Expr
+#         The values to update.
+
+#     axis : int
+#         The axis to scatter_add on
+
+#     Returns
+#     -------
+#     ret : relay.Expr
+#         The computed result.
+#     """
+#     return data1 + data2
diff --git a/python/tvm/topi/generic/search.py b/python/tvm/topi/generic/search.py
index b3c8772046f..c848dabb209 100644
--- a/python/tvm/topi/generic/search.py
+++ b/python/tvm/topi/generic/search.py
@@ -66,3 +66,17 @@ def schedule_scatter_add(outs):
       The computation schedule for the op.
     """
     return _default_schedule(outs, False)
+
+
+# def schedule_add2(outs):
+#     """Schedule for scatter_add operator.
+#     Parameters
+#     ----------
+#     outs: Array of Tensor
+#       The computation graph description of scatter_add.
+#     Returns
+#     -------
+#     s: Schedule
+#       The computation schedule for the op.
+#     """
+#     return _default_schedule(outs, False)
\ No newline at end of file
diff --git a/python/tvm/topi/image/resize.py b/python/tvm/topi/image/resize.py
index 103850de492..ef6706ab094 100644
--- a/python/tvm/topi/image/resize.py
+++ b/python/tvm/topi/image/resize.py
@@ -528,58 +528,58 @@ def _cast_output(value, data_dtype="float32", out_dtype=None):
     yfract = in_y - te.floor(in_y)
 
     # 1st row
-    p00 = _get_pixel(
+    p00 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint - 1, xint - 1, cc, inum, ic
     )
-    p10 = _get_pixel(
+    p10 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint - 1, xint + 0, cc, inum, ic
     )
-    p20 = _get_pixel(
+    p20 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint - 1, xint + 1, cc, inum, ic
     )
-    p30 = _get_pixel(
+    p30 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint - 1, xint + 2, cc, inum, ic
     )
 
     # 2nd row
-    p01 = _get_pixel(
+    p01 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 0, xint - 1, cc, inum, ic
     )
-    p11 = _get_pixel(
+    p11 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 0, xint + 0, cc, inum, ic
     )
-    p21 = _get_pixel(
+    p21 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 0, xint + 1, cc, inum, ic
     )
-    p31 = _get_pixel(
+    p31 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 0, xint + 2, cc, inum, ic
     )
 
     # 3rd row
-    p02 = _get_pixel(
+    p02 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 1, xint - 1, cc, inum, ic
     )
-    p12 = _get_pixel(
+    p12 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 1, xint + 0, cc, inum, ic
     )
-    p22 = _get_pixel(
+    p22 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 1, xint + 1, cc, inum, ic
     )
-    p32 = _get_pixel(
+    p32 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 1, xint + 2, cc, inum, ic
     )
 
     # 4th row
-    p03 = _get_pixel(
+    p03 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 2, xint - 1, cc, inum, ic
     )
-    p13 = _get_pixel(
+    p13 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 2, xint + 0, cc, inum, ic
     )
-    p23 = _get_pixel(
+    p23 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 2, xint + 1, cc, inum, ic
     )
-    p33 = _get_pixel(
+    p33 = get_2d_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 2, xint + 2, cc, inum, ic
     )
 
@@ -711,7 +711,7 @@ def _bicubic(*indices):
             in_w,
             size[0],
             size[1],
-            layout,
+            layout=layout,
             coordinate_transformation_mode=coordinate_transformation_mode,
             out_dtype=out_dtype,
         )
diff --git a/python/tvm/topi/transform.py b/python/tvm/topi/transform.py
index 6ddbc73e466..62ab91a829e 100644
--- a/python/tvm/topi/transform.py
+++ b/python/tvm/topi/transform.py
@@ -931,3 +931,22 @@ def adv_index(data, indices):
         Output tensor
     """
     return cpp.adv_index(data, indices)
+
+
+def add2(data1, data2):
+    """Numpy style indexing with tensors.
+
+    Parameters
+    ----------
+    data : tvm.te.Tensor
+        Input data.
+
+    indices : A list of tvm.te.Tensor
+        Tensor index.
+
+    Returns
+    -------
+    result : tvm.te.Tensor
+        Output tensor
+    """
+    return cpp.add2(data1, data2)
diff --git a/src/relay/op/tensor/transform.cc b/src/relay/op/tensor/transform.cc
index 5a13e9a5f92..e19e629c200 100644
--- a/src/relay/op/tensor/transform.cc
+++ b/src/relay/op/tensor/transform.cc
@@ -1339,12 +1339,11 @@ inline te::Tensor DynamicArange(const te::Tensor& start, const te::Tensor& stop,
                                 std::string name = "T_arange_dynamic",
                                 std::string tag = topi::kInjective) {
   tvm::PrimExpr num_elem = tvm::tir::Var("num_elem");
-  return te::compute(
-      {num_elem},
-      [&](const Array<tvm::tir::Var>& indices) {
-        return tvm::cast(dtype, start[0] + step[0] * indices[0]);
-      },
-      name, tag);
+  return te::compute({num_elem},
+                     [&](const Array<tvm::tir::Var>& indices) {
+                       return tvm::cast(dtype, start[0] + step[0] * indices[0]);
+                     },
+                     name, tag);
 }
 
 Array<te::Tensor> ArangeCompute(const Attrs& attrs, const Array<te::Tensor>& inputs,
@@ -1553,6 +1552,39 @@ RELAY_REGISTER_OP("meshgrid")
     .set_attr<FTVMCompute>("FTVMCompute", MeshgridCompute)
     .set_attr<TOpPattern>("TOpPattern", kInjective);
 
+bool Add2Rel(const Array<Type>& types, int num_inputs, const Attrs& raw_attrs,
+             const TypeReporter& reporter) {
+  // types: [data1, data2, result]
+  ICHECK_EQ(types.size(), 3);
+  reporter->Assign(types[1], types[0]);
+  return true;
+}
+
+Array<te::Tensor> Add2Compute(const Attrs& attrs, const Array<te::Tensor>& inputs,
+                              const Type& out_type) {
+  return {topi::add2(inputs[0], inputs[1])};
+}
+
+Expr MakeAdd2(Expr data1, Expr data2) {
+  static const Op& op = Op::Get("add2");
+  return Call(op, {data1, data2}, Attrs(), {});
+}
+
+TVM_REGISTER_GLOBAL("relay.op._make.add2").set_body_typed(MakeAdd2);
+
+RELAY_REGISTER_OP("add2")
+    .describe(R"code(Return twice of normal addition of two tensors.
+
+)code" TVM_ADD_FILELINE)
+    .set_num_inputs(2)
+    .add_argument("data1", "Tensor", "The first tensor")
+    .add_argument("data2", "Tensor", "The second tensor")
+    .set_support_level(3)
+    .add_type_rel("Add2", Add2Rel)
+    .set_attr<TOpPattern>("TOpPattern", kInjective)
+    .set_attr<FTVMCompute>("FTVMCompute", Add2Compute);
+// .set_attr<FTVMCompute>("FTVMCompute", Add2Compute)
+
 // tile operator
 TVM_REGISTER_NODE_TYPE(TileAttrs);
 
@@ -2404,16 +2436,16 @@ Array<te::Tensor> StridedSliceCompute(const Attrs& attrs, const Array<te::Tensor
           tir::make_const((strides.size() != 0 ? strides[0].dtype() : begin[0].dtype()),
                           (i < strides.size() ? strides[i]->value : 1)));
     }
-    return Array<te::Tensor>{te::compute(
-        out_shape,
-        [&](const Array<tir::Var>& indices) {
-          Array<PrimExpr> real_indices;
-          for (size_t i = 0; i < src_tensor_dim; ++i) {
-            real_indices.push_back(indices[i] * strides_expr[i] + begin_expr[i]);
-          }
-          return input(real_indices);
-        },
-        std::string{"T_strided_slice_dynamic"}, std::string{topi::kInjective})};
+    return Array<te::Tensor>{
+        te::compute(out_shape,
+                    [&](const Array<tir::Var>& indices) {
+                      Array<PrimExpr> real_indices;
+                      for (size_t i = 0; i < src_tensor_dim; ++i) {
+                        real_indices.push_back(indices[i] * strides_expr[i] + begin_expr[i]);
+                      }
+                      return input(real_indices);
+                    },
+                    std::string{"T_strided_slice_dynamic"}, std::string{topi::kInjective})};
   }
   return Array<te::Tensor>{topi::strided_slice(inputs[0], begin, end, strides, param->slice_mode)};
 }
diff --git a/src/relay/transforms/type_infer.cc b/src/relay/transforms/type_infer.cc
index 327b5d1e260..2567adb4049 100644
--- a/src/relay/transforms/type_infer.cc
+++ b/src/relay/transforms/type_infer.cc
@@ -572,9 +572,7 @@ class TypeInferencer : private ExprFunctor<Type(const Expr&)>,
     return FuncType(c->inputs, TypeCall(c->belong_to, types), td->type_vars, {});
   }
 
-  void Solve() {
-    solver_.Solve();
-  }
+  void Solve() { solver_.Solve(); }
 };
 
 class TypeInferencer::Resolver : public MixedModeMutator, PatternMutator {
diff --git a/tests/python/contrib/test_street_small.jpg b/tests/python/contrib/test_street_small.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..8a9f15ee972790f8fa7c99293f2ffb872a2d72ed
GIT binary patch
literal 119244
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

literal 0
HcmV?d00001

diff --git a/tests/python/contrib/test_tensorrt.py b/tests/python/contrib/test_tensorrt.py
index aadfa130365..ef99eb482f4 100644
--- a/tests/python/contrib/test_tensorrt.py
+++ b/tests/python/contrib/test_tensorrt.py
@@ -1222,5 +1222,38 @@ def get_maskrcnn_input(in_size: int) -> np.ndarray:
         )
 
 
+def test_tensorrt_conv_bn_3d():
+    if skip_codegen_test():
+        return
+    batches_to_test = [1, 1, 0, 2, 3, 0, 1, 3, 2]
+    x_shape = (relay.Any(), 3, 10, 224, 224)
+    x_data = np.ones([max(batches_to_test)] + list(x_shape)[1:]).astype("float32")
+    k_shape = (64, 3, 3, 3, 3)
+    params = {"kernel": np.random.uniform(-1, 1, k_shape).astype("float32")}
+    result_arr = [{} for _ in range(len(batches_to_test))]
+    for use_trt in [True, False]:
+        x = relay.var("x", shape=x_shape, dtype="float32")
+        kernel = relay.var("kernel", shape=k_shape, dtype="float32")
+        out = relay.nn.conv3d(x, kernel, channels=16, kernel_size=(3, 3), groups=1)
+        out = relay.nn.batch_norm(out, 0.1, 0.1, 0.1, 0.1)
+        f = relay.Function([x, kernel], out)
+        mod = tvm.IRModule()
+        mod["main"] = f
+        if use_trt:
+            mod, _ = tensorrt.partition_for_tensorrt(mod, params)
+
+        if not skip_runtime_test():
+            with relay.build_config(opt_level=3):
+                relay_exec = relay.create_executor("vm", mod=mod, ctx=tvm.cpu(0), target="llvm")
+
+            for i, batch_size in enumerate(batches_to_test):
+                result_arr[i][use_trt] = relay_exec.evaluate()(x_data[:batch_size, ...], **params)
+
+    if not skip_runtime_test():
+        for i in range(len(batches_to_test)):
+            assert_result_dict_holds(result_arr[i])
+
+
 if __name__ == "__main__":
-    pytest.main([__file__])
+    test_tensorrt_conv_bn_3d()
+    # pytest.main([__file__])
diff --git a/tests/python/relay/test_op_level3.py b/tests/python/relay/test_op_level3.py
index 82d05638166..15202c59cde 100644
--- a/tests/python/relay/test_op_level3.py
+++ b/tests/python/relay/test_op_level3.py
@@ -1035,6 +1035,41 @@ def verify_scatter_add(dshape, ishape, axis=0):
     verify_scatter_add((16, 16, 4, 5), (16, 16, 4, 5), 3)
 
 
+@tvm.testing.uses_gpu
+def test_add2():
+    def ref_scatter_add(data1, data2):
+        return 2 * (data1 + data2)
+
+    def verify_add2(dshape):
+        d1 = relay.var("d1", relay.TensorType(dshape, "float32"))
+        d2 = relay.var("d2", relay.TensorType(dshape, "float32"))
+        out = relay.var("out", relay.TensorType(dshape, "float32"))
+        z = relay.op.add2(d1, d2)
+
+        func = relay.Function([d1, d2], z)
+
+        data1_np = np.random.uniform(size=dshape).astype("float32")
+        data2_np = np.random.uniform(size=dshape).astype("float32")
+        ref_res = ref_scatter_add(data1_np, data2_np)
+        for target, ctx in tvm.testing.enabled_targets():
+            for kind in ["graph", "debug"]:
+                print("HERE")
+                intrp = relay.create_executor(kind, ctx=ctx, target=target)
+                print("HERE2")
+                op_res = intrp.evaluate(func)(data1_np, data2_np)
+                print("HERE3")
+                tvm.testing.assert_allclose(op_res.asnumpy(), ref_res, rtol=1e-5)
+
+    verify_add2((10,))
+    verify_add2((10, 5))
+    verify_add2((12, 4))
+    verify_add2((2, 3, 4))
+    verify_add2((2, 3, 4, 5))
+    verify_add2((6, 3, 4, 5))
+    verify_add2((2, 3, 8, 5))
+    verify_add2((16, 16, 4, 5))
+
+
 @tvm.testing.uses_gpu
 def test_gather():
     def verify_gather(data, axis, indices, ref_res):
@@ -1306,39 +1341,40 @@ def verify_adv_index(data_shape, index_shapes):
 
 
 if __name__ == "__main__":
-    test_cast()
-    test_zeros_ones()
-    test_unary_identity()
-    test_clip()
-    test_transpose_infer_type()
-    test_transpose()
-    test_reshape_infer_type()
-    test_reshape()
-    test_reshape_fail()
-    test_reshape_like_infer_type()
-    test_reshape_like()
-    test_take_infer_type()
-    test_take()
-    test_full_infer_type()
-    test_full()
-    test_full_like_infer_type()
-    test_full_like()
-    test_infer_type_leaky_relu()
-    test_infer_type_prelu()
-    test_squeeze()
-    test_squeeze_infer_type()
-    test_squeeze_bad_axes_infer_type()
-    test_split_infer_type()
-    test_arange()
-    test_meshgrid()
-    test_reverse()
-    test_stack()
-    test_tile()
-    test_repeat()
-    test_gather_nd()
-    test_isfinite()
-    test_isinf()
-    test_unravel_index()
-    test_sparse_to_dense()
-    test_fixed_point_multiply()
-    test_adv_index()
+    test_add2()
+    # test_cast()
+    # test_zeros_ones()
+    # test_unary_identity()
+    # test_clip()
+    # test_transpose_infer_type()
+    # test_transpose()
+    # test_reshape_infer_type()
+    # test_reshape()
+    # test_reshape_fail()
+    # test_reshape_like_infer_type()
+    # test_reshape_like()
+    # test_take_infer_type()
+    # test_take()
+    # test_full_infer_type()
+    # test_full()
+    # test_full_like_infer_type()
+    # test_full_like()
+    # test_infer_type_leaky_relu()
+    # test_infer_type_prelu()
+    # test_squeeze()
+    # test_squeeze_infer_type()
+    # test_squeeze_bad_axes_infer_type()
+    # test_split_infer_type()
+    # test_arange()
+    # test_meshgrid()
+    # test_reverse()
+    # test_stack()
+    # test_tile()
+    # test_repeat()
+    # test_gather_nd()
+    # test_isfinite()
+    # test_isinf()
+    # test_unravel_index()
+    # test_sparse_to_dense()
+    # test_fixed_point_multiply()
+    # test_adv_index()

From ff29e0caadf8a0c6168937fd8e3054f302f0d410 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Thu, 17 Dec 2020 19:24:35 +0000
Subject: [PATCH 07/36] SparseReshapeOp

---
 include/tvm/relay/attrs/transform.h     |   7 +
 include/tvm/topi/transform.h            | 188 ++++++++++++++++++---
 python/tvm/relay/op/_tensor.py          |   4 +-
 python/tvm/relay/op/_transform.py       |  16 +-
 python/tvm/relay/op/strategy/generic.py |   9 -
 python/tvm/relay/op/transform.py        |  12 +-
 python/tvm/topi/__init__.py             |   1 -
 python/tvm/topi/add2.py                 |  32 ----
 python/tvm/topi/generic/search.py       |  14 --
 python/tvm/topi/transform.py            |  23 ++-
 src/relay/op/tensor/transform.cc        | 105 +++++++++---
 tests/python/relay/test_op_level3.py    | 210 +++++++++++++++++++-----
 12 files changed, 482 insertions(+), 139 deletions(-)
 delete mode 100644 python/tvm/topi/add2.py

diff --git a/include/tvm/relay/attrs/transform.h b/include/tvm/relay/attrs/transform.h
index 3ed6b835284..86042d0220f 100644
--- a/include/tvm/relay/attrs/transform.h
+++ b/include/tvm/relay/attrs/transform.h
@@ -387,6 +387,13 @@ struct SparseToDenseAttrs : public tvm::AttrsNode<SparseToDenseAttrs> {
   }
 };  // struct SparseToDenseAttrs
 
+struct SparseFillEmptyRowsAttrs : public tvm::AttrsNode<SparseFillEmptyRowsAttrs> {
+  Array<Integer> dense_shape;
+
+  TVM_DECLARE_ATTRS(SparseFillEmptyRowsAttrs, "relay.attrs.SparseFillEmptyRowsAttrs") {
+    TVM_ATTR_FIELD(dense_shape).describe("Shape of the dense output tensor");
+  }
+};  // struct SparseFillEmptyRowsAttrs
 /*! \brief Attributes for ndarray_size operator */
 struct NdarraySizeAttrs : public tvm::AttrsNode<NdarraySizeAttrs> {
   DataType dtype;
diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index c90d7d7ac39..be31a77bb66 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -501,7 +501,7 @@ inline Array<Tensor> split(const Tensor& x, Array<PrimExpr> split_indices, int a
     begin_ids.push_back(idx);
   }
 
-  Array<Array<PrimExpr> > out_shapes;
+  Array<Array<PrimExpr>> out_shapes;
   for (size_t i = 0; i < begin_ids.size(); ++i) {
     PrimExpr out_axis_size;
     if (i == begin_ids.size() - 1) {
@@ -1344,27 +1344,173 @@ inline Array<Tensor> meshgrid(const Array<Tensor>& inputs, const std::string& in
   return result;
 }
 
-inline Tensor add2(const Tensor& data1, const Tensor& data2, std::string name = "T_add2",
-                   std::string tag = kInjective) {
-  // Array<PrimExpr> out_shape;
-  // for (size_t i = 0; i < inputs[0]->shape.size(); ++i) {
-  //   out_shape.push_back(inputs[0]->shape[i]);
-  // }
-  // Array<Tensor> result;
-  // for (size_t i = 0; i < inputs.size(); ++i) {
-  //   result.push_back(compute(out_shape,
-  //                            [&](const Array<Var>& indices) {
-  //                              const int src_index = (cartesian_indexing && i < 2) ? 1 - i : i;
-  //                              Array<PrimExpr> real_indices = {indices[src_index]};
-  //                              return inputs[i](real_indices);
-  //                            },
-  //                            name, tag));
-  // }
-  // return result;
-  return compute(data1->shape,
-                 [&](const Array<Var>& i) { return (data1(i) + data2(i) + data1(i) + data2(i)); },
-                 name, tag);
+inline Array<Tensor> SparseFillEmptyRows(const Tensor& sparse_indices, const Tensor& sparse_values,
+                                         const Tensor& default_value,
+                                         const Array<Integer>& dense_shape,
+                                         const std::string name = "T_sparsefillemptyrows",
+                                         std::string tag = kInjective) {
+  Array<Tensor> result;
+  Array<PrimExpr> sp_ordered_output_shape;
+  sp_ordered_output_shape.push_back(dense_shape[0] + sparse_indices->shape[0]);
+  if (sparse_indices->shape.size() > 1) {
+    sp_ordered_output_shape.push_back(sparse_indices->shape[1]);
+  }
+  int num_rows = static_cast<int>(dense_shape[0]) + GetConstInt(sparse_indices->shape[0]);
+  int num_cols = GetConstInt(sparse_indices->shape[1]);
+  std::vector<std::vector<PrimExpr>> sp_ordered_output(
+      num_rows, std::vector<PrimExpr>(num_cols, PrimExpr(-1)));
+
+  // std::vector<std::vector<int>> vec(100, std::vector<int>(400, 0));
+  std::vector<int> missing_indices;
+  std::vector<int> current_missing_index{0};
+  std::vector<int> total_missing_indices{0};
+  auto empty_row_indicator =
+      tvm::te::compute(Array<PrimExpr>{dense_shape[0]}, [&](const Array<Var>& indices) {
+        // for (int i = 0; i < GetConstInt(sparse_indices->shape[0]); ++i) {
+        //   sparse_indices[i]
+        // }
+        PrimExpr current_number = sparse_indices[indices[0] - total_missing_indices[0]];
+
+        bool cur_flag = true;
+        for (; cur_flag;) {
+          PrimExpr ret = if_then_else(current_number <= current_missing_index[0], 1, -1);
+          if (ret.as<IntImmNode>()->value == 1) {
+            PrimExpr ret2 = if_then_else(current_number == current_missing_index[0], 1, -1);
+            if (ret2.as<IntImmNode>()->value == 1) {
+              current_missing_index[0]++;
+              return PrimExpr(Bool(1));
+            } else {
+              current_number += 1;
+            }
+          } else {
+            total_missing_indices[0]++;
+          }
+        }
+        return PrimExpr(Bool(1));
+      });
+  result.push_back(compute(sp_ordered_output_shape,
+                           [&](const Array<Var>& indices) {
+                             PrimExpr ret = -1;
+                             //  ret += missing_index;
+                             //  int missing_index = 0;
+                             // PrimExpr current_missing_index = 0;
+                             // PrimExpr count_missing_indices = 0;
+                             // for (int i = 0; i < GetConstInt(sparse_indices->shape[0]); ++i)
+                             // {
+                             //   PrimExpr is_missing_index = if_then_else(sparse_indices[i][0]
+                             //   <= current_missing_index,
+                             //                                            current_missing_index,
+                             //                                            -1);
+                             //   if (const IntImmNode* op = is_missing_index.as<IntImmNode>())
+                             //   {
+                             //     if (op->value == -1) {
+                             //       PrimExpr on_current_indices =
+                             //           if_then_else(indices[0] == i + count_missing_indices,
+                             //           current_missing_index, -1);
+                             //       if (const IntImmNode* op =
+                             //       is_missing_index.as<IntImmNode>())
+                             //       {
+                             //         if (op->value == -1) {
+                             //           continue;
+                             //         } else {
+                             //           for (int j = 0; j < 6; ++j) {
+                             //             break;
+                             //           }
+                             //         }
+                             //       }
+                             //       count_missing_indices += 1;
+                             //     } else {
+                             //       PrimExpr current_missing_index =
+                             //           if_then_else(sparse_indices[i][0] ==
+                             //           current_missing_index,
+                             //                        current_missing_index + 1,
+                             //                        current_missing_index);
+                             //     }
+                             //   }
+                             // }
+                             return ret;
+                           },
+                           name, tag));
+  result.push_back(compute(Array<PrimExpr>{dense_shape[0]},
+                           [&](const Array<Var>& i) {
+                             PrimExpr ret = Bool(1);
+                             return ret;
+                           },
+                           name, tag));
+  return result;
 }
+
+inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& sparse_values,
+                                   const Tensor& prev_shape, const Tensor& new_shape,
+                                   const std::string name = "T_sparsereshape",
+                                   std::string tag = kInjective) {
+  Array<Tensor> result;
+  Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0], new_shape->shape[0]};
+  std::vector<PrimExpr> multipliers(GetConstInt(prev_shape->shape[0]), 1);
+  std::vector<PrimExpr> dividers(GetConstInt(new_shape->shape[0]), 1);
+
+  tvm::te::compute(Array<PrimExpr>{1}, [&](const Array<Var>& indices) {
+    tvm::PrimExpr total_ele = prev_shape[0];
+    for (int i = GetConstInt(prev_shape->shape[0]) - 2; i >= 0; --i) {
+      multipliers[i] = prev_shape[i + 1] * multipliers[i + 1];
+      total_ele *= prev_shape[i + 1];
+    }
+    PrimExpr division_total_ele = 1;
+    for (int i = 0; i < GetConstInt(new_shape->shape[0]); ++i) {
+      division_total_ele *= if_then_else(new_shape[i] != -1, new_shape[i], 1);
+    }
+    for (int i = GetConstInt(new_shape->shape[0]) - 2; i >= 0; --i) {
+      dividers[i] = dividers[i + 1] * if_then_else(new_shape[i + 1] != -1, new_shape[i + 1],
+                                                   div(total_ele, division_total_ele));
+    }
+    return PrimExpr(1);
+  });
+
+  result.push_back(compute(new_sparse_indices_shape,
+                           [&](const Array<Var>& indices) {
+                             PrimExpr flattened_idx = 0;
+                             if (sparse_indices->shape.size() == 1) {
+                               flattened_idx += sparse_indices[indices[0]];
+                             } else {
+                               for (int k = 0; k < GetConstInt(sparse_indices->shape[1]); k++) {
+                                 flattened_idx += (sparse_indices[indices[0]][k] * multipliers[k]);
+                               }
+                             }
+                             Array<PrimExpr> new_sparse_indices;
+                             if (GetConstInt(new_shape->shape[0]) != 1) {
+                               for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
+                                 new_sparse_indices.push_back(floordiv(flattened_idx, dividers[i]));
+                                 flattened_idx = floormod(flattened_idx, dividers[i]);
+                               }
+                               PrimExpr ret = -1;
+
+                               for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
+                                 //  auto ret = tir::Select(indices[1] == i, new_sparse_indices[i],
+                                 //  -1);
+                                 if (indices.size() == 1) {
+                                   return new_sparse_indices[0];
+                                 } else {
+                                   ret = if_then_else(indices[1] == i, new_sparse_indices[i], ret);
+                                   //  PrimExpr cond = (ret == -1);
+                                   if (const IntImmNode* op = ret.as<IntImmNode>()) {
+                                     if (op->value == -1) {
+                                       continue;
+                                     } else {
+                                       break;
+                                     }
+                                   }
+                                 }
+                               }
+                               return ret;
+                             } else {
+                               return flattened_idx;
+                             }
+                           },
+                           name, tag));
+  result.push_back(compute(sparse_values->shape,
+                           [&](const Array<Var>& i) { return (sparse_values(i)); }, name, tag));
+  return result;
+}  // namespace topi
 /*!
  * \brief Transform the layout according to \p src_layout and \p dst_layout
  * \param src the source input.
diff --git a/python/tvm/relay/op/_tensor.py b/python/tvm/relay/op/_tensor.py
index 69f5b8edf9d..f199ac563a1 100644
--- a/python/tvm/relay/op/_tensor.py
+++ b/python/tvm/relay/op/_tensor.py
@@ -21,10 +21,10 @@
 from tvm import topi
 from tvm.runtime import convert
 
-from .op import register_compute, register_shape_func
+from .op import register_compute, register_shape_func, register_strategy
 from .op import register_broadcast_schedule, register_injective_schedule
 from .op import register_pattern, OpPattern
-
+from . import strategy
 
 register_broadcast_schedule("log")
 register_broadcast_schedule("log2")
diff --git a/python/tvm/relay/op/_transform.py b/python/tvm/relay/op/_transform.py
index 093eee39fca..3f2d37d4868 100644
--- a/python/tvm/relay/op/_transform.py
+++ b/python/tvm/relay/op/_transform.py
@@ -63,7 +63,8 @@
 _reg.register_injective_schedule("sparse_to_dense")
 _reg.register_injective_schedule("matrix_set_diag")
 _reg.register_injective_schedule("adv_index")
-_reg.register_injective_schedule("add2")
+_reg.register_injective_schedule("sparsefillemptyrows")
+_reg.register_injective_schedule("sparsereshape")
 
 
 # concatenate
@@ -126,6 +127,18 @@ def compute_scatter_add(attrs, inputs, output_type):
 
 # _reg.register_schedule("add2", strategy.add2_strategy)
 
+
+# sparsefillemptyrows
+# @_reg.register_compute("sparsefillemptyrows")
+# def compute_sparsefillemptyrows(attrs, inputs, output_type):
+#     """Compute definition of sparsefillemptyrows"""
+#     return [topi.sparsefillemptyrows(inputs[0], inputs[1], inputs[2], inputs[3])]
+
+
+# _reg.register_schedule("sparsefillemptyrows", strategy.schedule_sparsefillemptyrows)
+
+# _reg.register_strategy("sparsefillemptyrows", strategy.sparsefillemptyrows_strategy)
+
 # scatter
 @_reg.register_compute("scatter_nd")
 def compute_scatter_nd(attrs, inputs, output_type):
@@ -456,6 +469,7 @@ def argwhere_shape_func(attrs, inputs, out_ndims):
 
 _reg.register_shape_func("scatter", False, elemwise_shape_func)
 _reg.register_shape_func("scatter_add", False, elemwise_shape_func)
+# _reg.register_shape_func("sparsefillemptyrows", False, elemwise_shape_func)
 
 
 @script
diff --git a/python/tvm/relay/op/strategy/generic.py b/python/tvm/relay/op/strategy/generic.py
index 018cd4ae980..ac9d3b157ec 100644
--- a/python/tvm/relay/op/strategy/generic.py
+++ b/python/tvm/relay/op/strategy/generic.py
@@ -1063,15 +1063,6 @@ def scatter_add_strategy(attrs, outs, out_type, target):
     return strategy
 
 
-# @override_native_generic_func("add2_strategy")
-# def add2_strategy(attrs, outs, out_type, target):
-#     strategy = _op.OpStrategy()
-#     strategy.add_implementation(
-#         wrap_compute_scatter(topi.add2),
-#         wrap_topi_schedule(topi.generic.schedule_add2),
-#         name="scatter_add.generic",
-#     )
-#     return strategy
 # scatter_nd
 @override_native_generic_func("scatter_nd_strategy")
 def scatter_nd_strategy(attrs, inputs, out_type, target):
diff --git a/python/tvm/relay/op/transform.py b/python/tvm/relay/op/transform.py
index 02efc8a870f..ba11488763a 100644
--- a/python/tvm/relay/op/transform.py
+++ b/python/tvm/relay/op/transform.py
@@ -1324,4 +1324,14 @@ def adv_index(inputs):
 
 def add2(data1, data2):
 
-    return _make.add2(data1, data2)
\ No newline at end of file
+    return _make.add2(data1, data2)
+
+
+def sparsefillemptyrows(sparse_indices, sparse_values, dense_shape, default_value):
+
+    return _make.sparsefillemptyrows(sparse_indices, sparse_values, dense_shape, default_value)
+
+
+def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
+
+    return _make.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)
\ No newline at end of file
diff --git a/python/tvm/topi/__init__.py b/python/tvm/topi/__init__.py
index f5f3f5bf187..fb962c28de2 100644
--- a/python/tvm/topi/__init__.py
+++ b/python/tvm/topi/__init__.py
@@ -40,7 +40,6 @@
 from .scatter import *
 from .scatter_add import *
 
-# from .add2 import *
 from .argwhere import *
 from . import generic
 from . import nn
diff --git a/python/tvm/topi/add2.py b/python/tvm/topi/add2.py
deleted file mode 100644
index 8c5685ea687..00000000000
--- a/python/tvm/topi/add2.py
+++ /dev/null
@@ -1,32 +0,0 @@
-# from tvm.te import hybrid
-
-# @hybrid.script
-# def add_2_helper(data1, data2):
-#     out = output_tensor(data1.shape, data1.dtype)
-#     out = data1 + data2
-#     return
-
-
-# def add2(data1, data2):
-#     """Update data by adding values in updates at positions defined by indices
-
-#     Parameters
-#     ----------
-#     data : relay.Expr
-#         The input data to the operator.
-
-#     indices : relay.Expr
-#         The index locations to update.
-
-#     updates : relay.Expr
-#         The values to update.
-
-#     axis : int
-#         The axis to scatter_add on
-
-#     Returns
-#     -------
-#     ret : relay.Expr
-#         The computed result.
-#     """
-#     return data1 + data2
diff --git a/python/tvm/topi/generic/search.py b/python/tvm/topi/generic/search.py
index c848dabb209..b3c8772046f 100644
--- a/python/tvm/topi/generic/search.py
+++ b/python/tvm/topi/generic/search.py
@@ -66,17 +66,3 @@ def schedule_scatter_add(outs):
       The computation schedule for the op.
     """
     return _default_schedule(outs, False)
-
-
-# def schedule_add2(outs):
-#     """Schedule for scatter_add operator.
-#     Parameters
-#     ----------
-#     outs: Array of Tensor
-#       The computation graph description of scatter_add.
-#     Returns
-#     -------
-#     s: Schedule
-#       The computation schedule for the op.
-#     """
-#     return _default_schedule(outs, False)
\ No newline at end of file
diff --git a/python/tvm/topi/transform.py b/python/tvm/topi/transform.py
index 62ab91a829e..1ff5a8096ba 100644
--- a/python/tvm/topi/transform.py
+++ b/python/tvm/topi/transform.py
@@ -933,7 +933,7 @@ def adv_index(data, indices):
     return cpp.adv_index(data, indices)
 
 
-def add2(data1, data2):
+def sparsefillemptyrows(sparse_indices, sparse_values, default_value, dense_shape):
     """Numpy style indexing with tensors.
 
     Parameters
@@ -949,4 +949,23 @@ def add2(data1, data2):
     result : tvm.te.Tensor
         Output tensor
     """
-    return cpp.add2(data1, data2)
+    return cpp.sparsefillemptyrows(sparse_indices, sparse_values, default_value, dense_shape)
+
+
+def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
+    """Numpy style indexing with tensors.
+
+    Parameters
+    ----------
+    data : tvm.te.Tensor
+        Input data.
+
+    indices : A list of tvm.te.Tensor
+        Tensor index.
+
+    Returns
+    -------
+    result : tvm.te.Tensor
+        Output tensor
+    """
+    return cpp.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)
\ No newline at end of file
diff --git a/src/relay/op/tensor/transform.cc b/src/relay/op/tensor/transform.cc
index e19e629c200..8d21b9262cd 100644
--- a/src/relay/op/tensor/transform.cc
+++ b/src/relay/op/tensor/transform.cc
@@ -1552,38 +1552,105 @@ RELAY_REGISTER_OP("meshgrid")
     .set_attr<FTVMCompute>("FTVMCompute", MeshgridCompute)
     .set_attr<TOpPattern>("TOpPattern", kInjective);
 
-bool Add2Rel(const Array<Type>& types, int num_inputs, const Attrs& raw_attrs,
-             const TypeReporter& reporter) {
-  // types: [data1, data2, result]
-  ICHECK_EQ(types.size(), 3);
-  reporter->Assign(types[1], types[0]);
+bool SparseReshapeRel(const Array<Type>& types, int num_inputs, const Attrs& raw_attrs,
+                      const TypeReporter& reporter) {
+  // types: [sparse_indices, sparse_values, prev_shape, new_shape, result]
+  ICHECK_EQ(types.size(), 5);
+
+  std::vector<Type> fields;
+  auto sparse_indices = types[0].as<TensorTypeNode>();
+  auto sparse_values = types[1].as<TensorTypeNode>();
+  auto new_shape = types[3].as<TensorTypeNode>();
+
+  Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0], new_shape->shape[0]};
+  fields.push_back(TensorType(new_sparse_indices_shape, sparse_indices->dtype));
+  fields.push_back(TensorType(sparse_values->shape, sparse_values->dtype));
+
+  reporter->Assign(types[4], TupleType(Array<Type>(fields)));
   return true;
 }
 
-Array<te::Tensor> Add2Compute(const Attrs& attrs, const Array<te::Tensor>& inputs,
-                              const Type& out_type) {
-  return {topi::add2(inputs[0], inputs[1])};
+Array<te::Tensor> SparseReshapeCompute(const Attrs& attrs, const Array<te::Tensor>& inputs,
+                                       const Type& out_type) {
+  return {topi::SparseReshape(inputs[0], inputs[1], inputs[2], inputs[3])};
 }
 
-Expr MakeAdd2(Expr data1, Expr data2) {
-  static const Op& op = Op::Get("add2");
-  return Call(op, {data1, data2}, Attrs(), {});
+Expr MakeSparseReshape(Expr sparse_indices, Expr sparse_values, Expr prev_shape, Expr new_shape) {
+  static const Op& op = Op::Get("sparsereshape");
+  return Call(op, {sparse_indices, sparse_values, prev_shape, new_shape}, Attrs(), {});
 }
 
-TVM_REGISTER_GLOBAL("relay.op._make.add2").set_body_typed(MakeAdd2);
+TVM_REGISTER_GLOBAL("relay.op._make.sparsereshape").set_body_typed(MakeSparseReshape);
 
-RELAY_REGISTER_OP("add2")
+RELAY_REGISTER_OP("sparsereshape")
     .describe(R"code(Return twice of normal addition of two tensors.
 
 )code" TVM_ADD_FILELINE)
-    .set_num_inputs(2)
-    .add_argument("data1", "Tensor", "The first tensor")
-    .add_argument("data2", "Tensor", "The second tensor")
+    .set_num_inputs(4)
+    .add_argument("sparse_indices", "Tensor", "The first tensor")
+    .add_argument("sparse_values", "Tensor", "The second tensor")
+    .add_argument("prev_shape", "Tensor", "The third tensor")
+    .add_argument("new_shape", "Tensor", "The fourth tensor")
+    .add_type_rel("sparsereshape", SparseReshapeRel)
+    .set_attr<TOpPattern>("TOpPattern", kInjective)
+    .set_support_level(3)
+    .set_attr<FTVMCompute>("FTVMCompute", SparseReshapeCompute);
+
+TVM_REGISTER_NODE_TYPE(SparseFillEmptyRowsAttrs);
+
+bool SparseFillEmptyRowsRel(const Array<Type>& types, int num_inputs, const Attrs& attrs,
+                            const TypeReporter& reporter) {
+  // types: [ sparse_indices, sparse_values, default_value, result]
+  ICHECK_EQ(types.size(), 4);
+  ICHECK_EQ(num_inputs, 3);
+  std::vector<Type> fields;
+  auto sparse_indices = types[0].as<TensorTypeNode>();
+
+  const auto* param = attrs.as<SparseFillEmptyRowsAttrs>();
+  CHECK(param != nullptr);
+
+  Array<IndexExpr> sp_ordered_output_shape;
+  sp_ordered_output_shape.push_back(param->dense_shape[0] + sparse_indices->shape[0]);
+  if (sparse_indices->shape.size() > 1) {
+    sp_ordered_output_shape.push_back(sparse_indices->shape[1]);
+  }
+  fields.push_back(TensorType(sp_ordered_output_shape, sparse_indices->dtype));
+  fields.push_back(TensorType(Array<PrimExpr>{param->dense_shape[0]}, tvm::DataType::Bool()));
+  reporter->Assign(types[3], TupleType(Array<Type>(fields)));
+  return true;
+}
+
+Array<te::Tensor> SparseFillEmptyRowsCompute(const Attrs& attrs, const Array<te::Tensor>& inputs,
+                                             const Type& out_type) {
+  CHECK_EQ(inputs.size(), 3);
+  const auto* param = attrs.as<SparseFillEmptyRowsAttrs>();
+  CHECK(param != nullptr);
+  return {topi::SparseFillEmptyRows(inputs[0], inputs[1], inputs[2], param->dense_shape)};
+}
+
+Expr MakeSparseFillEmptyRows(Expr sparse_indices, Expr sparse_values, Expr default_value,
+                             Array<Integer> dense_shape) {
+  auto attrs = make_object<SparseFillEmptyRowsAttrs>();
+  attrs->dense_shape = std::move(dense_shape);
+  static const Op& op = Op::Get("sparsefillemptyrows");
+  return Call(op, {sparse_indices, sparse_values, default_value}, Attrs(attrs), {});
+}
+
+TVM_REGISTER_GLOBAL("relay.op._make.sparsefillemptyrows").set_body_typed(MakeSparseFillEmptyRows);
+
+RELAY_REGISTER_OP("sparsefillemptyrows")
+    .describe(R"code(Return twice of normal addition of two tensors.
+
+)code" TVM_ADD_FILELINE)
+    .set_num_inputs(3)
+    .set_attrs_type<SparseFillEmptyRowsAttrs>()
+    .add_argument("sparse_indices", "Tensor", "The first tensor")
+    .add_argument("sparse_values", "Tensor", "The second tensor")
+    .add_argument("default_value", "Tensor", "The third tensor")
+    .add_type_rel("sparsefillemptyrows", SparseFillEmptyRowsRel)
     .set_support_level(3)
-    .add_type_rel("Add2", Add2Rel)
     .set_attr<TOpPattern>("TOpPattern", kInjective)
-    .set_attr<FTVMCompute>("FTVMCompute", Add2Compute);
-// .set_attr<FTVMCompute>("FTVMCompute", Add2Compute)
+    .set_attr<FTVMCompute>("FTVMCompute", SparseFillEmptyRowsCompute);
 
 // tile operator
 TVM_REGISTER_NODE_TYPE(TileAttrs);
diff --git a/tests/python/relay/test_op_level3.py b/tests/python/relay/test_op_level3.py
index 15202c59cde..e04f1812980 100644
--- a/tests/python/relay/test_op_level3.py
+++ b/tests/python/relay/test_op_level3.py
@@ -1016,58 +1016,191 @@ def verify_scatter_add(dshape, ishape, axis=0):
 
         ref_res = ref_scatter_add(data_np, indices_np, updates_np, axis)
         for target, ctx in tvm.testing.enabled_targets():
+            if target == "nvptx":
+                continue
+            print(target)
             for kind in ["graph", "debug"]:
                 intrp = relay.create_executor(kind, ctx=ctx, target=target)
                 op_res = intrp.evaluate(func)(data_np, indices_np, updates_np)
                 tvm.testing.assert_allclose(op_res.asnumpy(), ref_res, rtol=1e-5)
 
-    verify_scatter_add((10,), (10,), 0)
+    # verify_scatter_add((10,), (10,), 0)
     verify_scatter_add((10, 5), (10, 5), -2)
-    verify_scatter_add((10, 5), (10, 5), -1)
-    verify_scatter_add((10, 5), (3, 5), 0)
-    verify_scatter_add((12, 4), (7, 2), 1)
-    verify_scatter_add((2, 3, 4), (1, 3, 4), 0)
-    verify_scatter_add((2, 3, 4), (2, 1, 4), 1)
-    verify_scatter_add((2, 3, 4), (2, 3, 1), 2)
-    verify_scatter_add((2, 3, 4, 5), (1, 3, 4, 5), 0)
-    verify_scatter_add((6, 3, 4, 5), (2, 3, 4, 5), 1)
-    verify_scatter_add((2, 3, 8, 5), (2, 3, 1, 1), 2)
-    verify_scatter_add((16, 16, 4, 5), (16, 16, 4, 5), 3)
+    # verify_scatter_add((10, 5), (10, 5), -1)
+    # verify_scatter_add((10, 5), (3, 5), 0)
+    # verify_scatter_add((12, 4), (7, 2), 1)
+    # verify_scatter_add((2, 3, 4), (1, 3, 4), 0)
+    # verify_scatter_add((2, 3, 4), (2, 1, 4), 1)
+    # verify_scatter_add((2, 3, 4), (2, 3, 1), 2)
+    # verify_scatter_add((2, 3, 4, 5), (1, 3, 4, 5), 0)
+    # verify_scatter_add((6, 3, 4, 5), (2, 3, 4, 5), 1)
+    # verify_scatter_add((2, 3, 8, 5), (2, 3, 1, 1), 2)
+    # verify_scatter_add((16, 16, 4, 5), (16, 16, 4, 5), 3)
 
 
 @tvm.testing.uses_gpu
-def test_add2():
-    def ref_scatter_add(data1, data2):
-        return 2 * (data1 + data2)
+def test_sparsefillemptyrows():
+    def ref_sparsefillemptyrows(sparse_indices, sparse_values, default_value, dense_shape):
+        new_sparse_indices = -1 * np.ones(
+            (sparse_indices.shape[0] + dense_shape[0], sparse_indices.shape[1])
+        )
+        empty_row_indicator = np.ones(dense_shape[0], dtype=bool)
+
+        return new_sparse_indices, empty_row_indicator
 
-    def verify_add2(dshape):
-        d1 = relay.var("d1", relay.TensorType(dshape, "float32"))
-        d2 = relay.var("d2", relay.TensorType(dshape, "float32"))
-        out = relay.var("out", relay.TensorType(dshape, "float32"))
-        z = relay.op.add2(d1, d2)
+    def verify_sparsefillemptyrows(
+        sparse_indices_np, sparse_values_np, default_value_np, dense_shape_np
+    ):
+        sparse_indices = relay.var(
+            "sparse_indices",
+            relay.TensorType(sparse_indices_np.shape, str(sparse_indices_np.dtype)),
+        )
+        sparse_values = relay.var(
+            "sparse_values", relay.TensorType(sparse_values_np.shape, str(sparse_values_np.dtype))
+        )
+        default_value = relay.var(
+            "default_value", relay.TensorType(default_value_np.shape, str(default_value_np.dtype))
+        )
+        z = relay.op.sparsefillemptyrows(
+            sparse_indices, sparse_values, default_value, list(dense_shape_np)
+        )
 
-        func = relay.Function([d1, d2], z)
+        func = relay.Function([sparse_indices, sparse_values, default_value], z)
 
-        data1_np = np.random.uniform(size=dshape).astype("float32")
-        data2_np = np.random.uniform(size=dshape).astype("float32")
-        ref_res = ref_scatter_add(data1_np, data2_np)
+        ref_res = ref_sparsefillemptyrows(
+            sparse_indices_np, sparse_values_np, default_value_np, dense_shape_np
+        )
         for target, ctx in tvm.testing.enabled_targets():
+            if target == "nvptx":
+                continue
             for kind in ["graph", "debug"]:
-                print("HERE")
                 intrp = relay.create_executor(kind, ctx=ctx, target=target)
-                print("HERE2")
-                op_res = intrp.evaluate(func)(data1_np, data2_np)
-                print("HERE3")
-                tvm.testing.assert_allclose(op_res.asnumpy(), ref_res, rtol=1e-5)
+                op_res = intrp.evaluate(func)(sparse_indices_np, sparse_values_np, default_value_np)
+                for op_res_item, ref_res_item in zip(op_res, ref_res):
+                    print(op_res_item, ref_res_item)
+                    tvm.testing.assert_allclose(op_res_item.asnumpy(), ref_res_item, rtol=1e-5)
+
+    sparse_indices_np = np.array([[0, 1], [0, 3], [2, 0], [3, 1]], dtype=np.int32)
+    sparse_values_np = np.array([1, 2, 3, 4], dtype=np.int32)
+    dense_shape_np = np.array([5, 6], dtype=np.int32)
+    default_value_np = np.array([10], dtype=np.int32)
+    verify_sparsefillemptyrows(
+        sparse_indices_np, sparse_values_np, default_value_np, dense_shape_np
+    )
+    print("Sparse Fill Empty Rows Verified !!")
+
+
+@tvm.testing.uses_gpu
+def test_sparsereshape():
+    def ref_sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
+        # sparse_indices[0][0] = 1
+        new_sparse_indices = np.ones(
+            (sparse_values.shape[0], new_shape.shape[0]), dtype=sparse_indices.dtype
+        )
+        multipliers = np.ones(prev_shape.shape[0])
+        dividers = np.ones(new_shape.shape[0])
+        total_ele = np.prod(prev_shape)
+        division_total_ele = 1
+        for i in range(new_shape.shape[0]):
+            if new_shape[i] == -1:
+                continue
+            division_total_ele *= new_shape[i]
+        for i in range(prev_shape.shape[0] - 2, -1, -1):
+            multipliers[i] = prev_shape[i + 1] * multipliers[i + 1]
+        for i in range(new_shape.shape[0] - 2, -1, -1):
+            if new_shape[i + 1] == -1:
+                dividers[i] = (total_ele // division_total_ele) * dividers[i + 1]
+            else:
+                dividers[i] = new_shape[i + 1] * dividers[i + 1]
+        for row_num, sparse_row in enumerate(sparse_indices):
+            flat_idx = 0
+            if len(sparse_indices.shape) != 1:
+                for i, ele in enumerate(sparse_row):
+                    flat_idx += sparse_row[i] * multipliers[i]
+            else:
+                flat_idx += sparse_row
+            if len(new_sparse_indices.shape) != 1:
+                for i in range(new_sparse_indices.shape[1]):
+                    new_sparse_indices[row_num][i] = flat_idx // dividers[i]
+                    flat_idx = flat_idx % dividers[i]
+            else:
+                new_sparse_indices[row_num] = flat_idx
 
-    verify_add2((10,))
-    verify_add2((10, 5))
-    verify_add2((12, 4))
-    verify_add2((2, 3, 4))
-    verify_add2((2, 3, 4, 5))
-    verify_add2((6, 3, 4, 5))
-    verify_add2((2, 3, 8, 5))
-    verify_add2((16, 16, 4, 5))
+        return (
+            new_sparse_indices,
+            sparse_values,
+        )
+
+    def verify_sparsereshape(sparse_indices_np, sparse_values_np, dense_shape_np, default_value_np):
+        sparse_indices = relay.var(
+            "sparse_indices",
+            relay.TensorType(sparse_indices_np.shape, str(sparse_indices_np.dtype)),
+        )
+        sparse_values = relay.var(
+            "sparse_values", relay.TensorType(sparse_values_np.shape, str(sparse_values_np.dtype))
+        )
+        dense_shape = relay.var(
+            "dense_shape", relay.TensorType(dense_shape_np.shape, str(dense_shape_np.dtype))
+        )
+        default_value = relay.var(
+            "default_value", relay.TensorType(default_value_np.shape, str(default_value_np.dtype))
+        )
+        z = relay.op.sparsereshape(sparse_indices, sparse_values, dense_shape, default_value)
+
+        func = relay.Function([sparse_indices, sparse_values, dense_shape, default_value], z)
+
+        ref_res = ref_sparsereshape(
+            sparse_indices_np, sparse_values_np, dense_shape_np, default_value_np
+        )
+        for target, ctx in tvm.testing.enabled_targets():
+            if target == "nvptx":
+                continue
+            for kind in ["graph", "debug"]:
+                intrp = relay.create_executor(kind, ctx=ctx, target=target)
+                op_res = intrp.evaluate(func)(
+                    sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np
+                )
+                for op_res_item, ref_res_item in zip(op_res, ref_res):
+                    print(f"Op Res: {op_res_item}, Ref Res: {ref_res_item}")
+                    tvm.testing.assert_allclose(
+                        op_res_item.asnumpy(), ref_res_item, rtol=1e-5, atol=1e-5
+                    )
+
+    sparse_indices_np = np.array(
+        [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]], dtype=np.int32
+    )
+    sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    prev_shape_np = np.array([2, 3, 6], dtype=np.int32)
+    new_shape_np = np.array([9, 4], dtype=np.int32)
+    verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+
+    # sparse_indices_np = np.array(
+    #     [[0, 0, 0, 0], [0, 0, 1, 2], [0, 1, 0, 3], [1, 0, 0, 4], [1, 2, 3, 6]], dtype=np.int32
+    # )
+    # sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    # prev_shape_np = np.array([2, 3, 6, 7], dtype=np.int32)
+    # new_shape_np = np.array([9, -1, 7], dtype=np.int32)
+    # verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+
+    # sparse_indices_np = np.array([[0, 0], [0, 1], [3, 4], [4, 3], [7, 3]], dtype=np.int32)
+    # sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    # prev_shape_np = np.array([9, 4], dtype=np.int32)
+    # new_shape_np = np.array([2, -1, 6], dtype=np.int32)
+    # verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+
+    # sparse_indices_np = np.array([[0, 0], [0, 1], [3, 4], [4, 3], [7, 3]], dtype=np.int32)
+    # sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    # prev_shape_np = np.array([9, 4], dtype=np.int32)
+    # new_shape_np = np.array([-1], dtype=np.int32)
+    # verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+
+    # sparse_indices_np = np.array([0, 5, 10, 20, 24], dtype=np.int32)
+    # sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    # prev_shape_np = np.array([25], dtype=np.int32)
+    # new_shape_np = np.array([5, 5], dtype=np.int32)
+    # verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+
+    # print("Sparse Reshape Verified !!")
 
 
 @tvm.testing.uses_gpu
@@ -1341,7 +1474,10 @@ def verify_adv_index(data_shape, index_shapes):
 
 
 if __name__ == "__main__":
-    test_add2()
+    # test_add2()
+    # test_scatter_add()
+    test_sparsefillemptyrows()
+    # test_sparsereshape()
     # test_cast()
     # test_zeros_ones()
     # test_unary_identity()

From fe3f7ded49d1e10c9ef1ec26e1870061a94adaa6 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Thu, 17 Dec 2020 19:27:56 +0000
Subject: [PATCH 08/36] Remove Build Module changes

---
 python/tvm/relay/build_module.py | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/python/tvm/relay/build_module.py b/python/tvm/relay/build_module.py
index 6a059c96b0c..5dc6f81b97a 100644
--- a/python/tvm/relay/build_module.py
+++ b/python/tvm/relay/build_module.py
@@ -244,9 +244,6 @@ def build(mod, target=None, target_host=None, params=None, mod_name="default"):
     # pylint: enable=line-too-long
     # fmt: on
     if not isinstance(mod, (IRModule, _function.Function)):
-
-        # print(f"Mod : { mod.astext(show_meta_data=False)}")
-        # print(f"Type Mod: {type(mod)}")
         raise ValueError("Type of input parameter mod must be tvm.IRModule")
 
     if isinstance(mod, _function.Function):

From 3f5de527faf882cb34537593ad7c3ddc0e53925b Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Thu, 17 Dec 2020 21:34:31 +0000
Subject: [PATCH 09/36] Reset non-op changes

---
 tests/python/contrib/test_tensorrt.py | 35 +--------------------------
 1 file changed, 1 insertion(+), 34 deletions(-)

diff --git a/tests/python/contrib/test_tensorrt.py b/tests/python/contrib/test_tensorrt.py
index 1c9b423b498..9b62ee2c408 100644
--- a/tests/python/contrib/test_tensorrt.py
+++ b/tests/python/contrib/test_tensorrt.py
@@ -1228,38 +1228,5 @@ def get_maskrcnn_input(in_size: int) -> np.ndarray:
         )
 
 
-def test_tensorrt_conv_bn_3d():
-    if skip_codegen_test():
-        return
-    batches_to_test = [1, 1, 0, 2, 3, 0, 1, 3, 2]
-    x_shape = (relay.Any(), 3, 10, 224, 224)
-    x_data = np.ones([max(batches_to_test)] + list(x_shape)[1:]).astype("float32")
-    k_shape = (64, 3, 3, 3, 3)
-    params = {"kernel": np.random.uniform(-1, 1, k_shape).astype("float32")}
-    result_arr = [{} for _ in range(len(batches_to_test))]
-    for use_trt in [True, False]:
-        x = relay.var("x", shape=x_shape, dtype="float32")
-        kernel = relay.var("kernel", shape=k_shape, dtype="float32")
-        out = relay.nn.conv3d(x, kernel, channels=16, kernel_size=(3, 3), groups=1)
-        out = relay.nn.batch_norm(out, 0.1, 0.1, 0.1, 0.1)
-        f = relay.Function([x, kernel], out)
-        mod = tvm.IRModule()
-        mod["main"] = f
-        if use_trt:
-            mod, _ = tensorrt.partition_for_tensorrt(mod, params)
-
-        if not skip_runtime_test():
-            with relay.build_config(opt_level=3):
-                relay_exec = relay.create_executor("vm", mod=mod, ctx=tvm.cpu(0), target="llvm")
-
-            for i, batch_size in enumerate(batches_to_test):
-                result_arr[i][use_trt] = relay_exec.evaluate()(x_data[:batch_size, ...], **params)
-
-    if not skip_runtime_test():
-        for i in range(len(batches_to_test)):
-            assert_result_dict_holds(result_arr[i])
-
-
 if __name__ == "__main__":
-    test_tensorrt_conv_bn_3d()
-    # pytest.main([__file__])
+    pytest.main([__file__])

From a521c1b3173fc50e32cc508e20bac44e47963213 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Thu, 17 Dec 2020 21:36:05 +0000
Subject: [PATCH 10/36] Remove stuff

---
 tests/python/contrib/test_street_small.jpg | Bin 119244 -> 0 bytes
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 tests/python/contrib/test_street_small.jpg

diff --git a/tests/python/contrib/test_street_small.jpg b/tests/python/contrib/test_street_small.jpg
deleted file mode 100644
index 8a9f15ee972790f8fa7c99293f2ffb872a2d72ed..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 119244
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


From 04da7d43e84543dcb6403f38bf4988f0a248bc19 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Thu, 17 Dec 2020 21:38:43 +0000
Subject: [PATCH 11/36] More changes

---
 python/tvm/relay/op/_transform.py       | 21 ---------------
 python/tvm/relay/op/contrib/tensorrt.py |  2 +-
 python/tvm/topi/__init__.py             |  1 -
 python/tvm/topi/image/resize.py         | 34 ++++++++++++-------------
 4 files changed, 18 insertions(+), 40 deletions(-)

diff --git a/python/tvm/relay/op/_transform.py b/python/tvm/relay/op/_transform.py
index a3c4f968099..20e73a40e4a 100644
--- a/python/tvm/relay/op/_transform.py
+++ b/python/tvm/relay/op/_transform.py
@@ -106,27 +106,6 @@ def compute_scatter_add(attrs, inputs, output_type):
 
 _reg.register_strategy("scatter_add", strategy.scatter_add_strategy)
 
-
-# @_reg.register_compute("add2")
-# def compute_scatter_add(attrs, inputs, output_type):
-#     """Compute definition of scatter_add"""
-#     return [topi.add2(inputs[0], inputs[1])]
-
-
-# _reg.register_schedule("add2", strategy.add2_strategy)
-
-
-# sparsefillemptyrows
-# @_reg.register_compute("sparsefillemptyrows")
-# def compute_sparsefillemptyrows(attrs, inputs, output_type):
-#     """Compute definition of sparsefillemptyrows"""
-#     return [topi.sparsefillemptyrows(inputs[0], inputs[1], inputs[2], inputs[3])]
-
-
-# _reg.register_schedule("sparsefillemptyrows", strategy.schedule_sparsefillemptyrows)
-
-# _reg.register_strategy("sparsefillemptyrows", strategy.sparsefillemptyrows_strategy)
-
 # scatter
 @_reg.register_compute("scatter_nd")
 def compute_scatter_nd(attrs, inputs, output_type):
diff --git a/python/tvm/relay/op/contrib/tensorrt.py b/python/tvm/relay/op/contrib/tensorrt.py
index 1efce753cf1..bda71468d9e 100644
--- a/python/tvm/relay/op/contrib/tensorrt.py
+++ b/python/tvm/relay/op/contrib/tensorrt.py
@@ -631,7 +631,7 @@ def reshape_annotate_fn(expr):  # pylint: disable=unused-variable
         if dynamic_reshape:
             # Make sure that the batch dim is unmodified.
             if int(new_shape[0]) < 0:
-                for shape_val, new_shape_val in zip(shape[1:], new_shape[1:]):
+                for shape_val, new_shape_val in enumerate(shape[1:], new_shape[1:]):
                     if not (
                         isinstance(shape_val, int)
                         and isinstance(new_shape_val, int)
diff --git a/python/tvm/topi/__init__.py b/python/tvm/topi/__init__.py
index fb962c28de2..97951d941f6 100644
--- a/python/tvm/topi/__init__.py
+++ b/python/tvm/topi/__init__.py
@@ -39,7 +39,6 @@
 from .sort import *
 from .scatter import *
 from .scatter_add import *
-
 from .argwhere import *
 from . import generic
 from . import nn
diff --git a/python/tvm/topi/image/resize.py b/python/tvm/topi/image/resize.py
index ef6706ab094..103850de492 100644
--- a/python/tvm/topi/image/resize.py
+++ b/python/tvm/topi/image/resize.py
@@ -528,58 +528,58 @@ def _cast_output(value, data_dtype="float32", out_dtype=None):
     yfract = in_y - te.floor(in_y)
 
     # 1st row
-    p00 = get_2d_pixel(
+    p00 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint - 1, xint - 1, cc, inum, ic
     )
-    p10 = get_2d_pixel(
+    p10 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint - 1, xint + 0, cc, inum, ic
     )
-    p20 = get_2d_pixel(
+    p20 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint - 1, xint + 1, cc, inum, ic
     )
-    p30 = get_2d_pixel(
+    p30 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint - 1, xint + 2, cc, inum, ic
     )
 
     # 2nd row
-    p01 = get_2d_pixel(
+    p01 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 0, xint - 1, cc, inum, ic
     )
-    p11 = get_2d_pixel(
+    p11 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 0, xint + 0, cc, inum, ic
     )
-    p21 = get_2d_pixel(
+    p21 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 0, xint + 1, cc, inum, ic
     )
-    p31 = get_2d_pixel(
+    p31 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 0, xint + 2, cc, inum, ic
     )
 
     # 3rd row
-    p02 = get_2d_pixel(
+    p02 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 1, xint - 1, cc, inum, ic
     )
-    p12 = get_2d_pixel(
+    p12 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 1, xint + 0, cc, inum, ic
     )
-    p22 = get_2d_pixel(
+    p22 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 1, xint + 1, cc, inum, ic
     )
-    p32 = get_2d_pixel(
+    p32 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 1, xint + 2, cc, inum, ic
     )
 
     # 4th row
-    p03 = get_2d_pixel(
+    p03 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 2, xint - 1, cc, inum, ic
     )
-    p13 = get_2d_pixel(
+    p13 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 2, xint + 0, cc, inum, ic
     )
-    p23 = get_2d_pixel(
+    p23 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 2, xint + 1, cc, inum, ic
     )
-    p33 = get_2d_pixel(
+    p33 = _get_pixel(
         data, layout, boxes, image_height, image_width, box_idx, c, yint + 2, xint + 2, cc, inum, ic
     )
 
@@ -711,7 +711,7 @@ def _bicubic(*indices):
             in_w,
             size[0],
             size[1],
-            layout=layout,
+            layout,
             coordinate_transformation_mode=coordinate_transformation_mode,
             out_dtype=out_dtype,
         )

From c32b2dd1ba19ab82dc72378eda6de59cf8cc0f4d Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Thu, 17 Dec 2020 21:40:38 +0000
Subject: [PATCH 12/36] Op Level 3

---
 tests/python/relay/test_op_level3.py | 77 ++++++++++++++--------------
 1 file changed, 38 insertions(+), 39 deletions(-)

diff --git a/tests/python/relay/test_op_level3.py b/tests/python/relay/test_op_level3.py
index 142e93a2346..51c62bf4f26 100644
--- a/tests/python/relay/test_op_level3.py
+++ b/tests/python/relay/test_op_level3.py
@@ -1481,43 +1481,42 @@ def verify_adv_index(data_shape, index_shapes):
 
 
 if __name__ == "__main__":
-    # test_add2()
-    # test_scatter_add()
+    test_scatter_add()
     test_sparsefillemptyrows()
-    # test_sparsereshape()
-    # test_cast()
-    # test_zeros_ones()
-    # test_unary_identity()
-    # test_clip()
-    # test_transpose_infer_type()
-    # test_transpose()
-    # test_reshape_infer_type()
-    # test_reshape()
-    # test_reshape_fail()
-    # test_reshape_like_infer_type()
-    # test_reshape_like()
-    # test_take_infer_type()
-    # test_take()
-    # test_full_infer_type()
-    # test_full()
-    # test_full_like_infer_type()
-    # test_full_like()
-    # test_infer_type_leaky_relu()
-    # test_infer_type_prelu()
-    # test_squeeze()
-    # test_squeeze_infer_type()
-    # test_squeeze_bad_axes_infer_type()
-    # test_split_infer_type()
-    # test_arange()
-    # test_meshgrid()
-    # test_reverse()
-    # test_stack()
-    # test_tile()
-    # test_repeat()
-    # test_gather_nd()
-    # test_isfinite()
-    # test_isinf()
-    # test_unravel_index()
-    # test_sparse_to_dense()
-    # test_fixed_point_multiply()
-    # test_adv_index()
+    test_sparsereshape()
+    test_cast()
+    test_zeros_ones()
+    test_unary_identity()
+    test_clip()
+    test_transpose_infer_type()
+    test_transpose()
+    test_reshape_infer_type()
+    test_reshape()
+    test_reshape_fail()
+    test_reshape_like_infer_type()
+    test_reshape_like()
+    test_take_infer_type()
+    test_take()
+    test_full_infer_type()
+    test_full()
+    test_full_like_infer_type()
+    test_full_like()
+    test_infer_type_leaky_relu()
+    test_infer_type_prelu()
+    test_squeeze()
+    test_squeeze_infer_type()
+    test_squeeze_bad_axes_infer_type()
+    test_split_infer_type()
+    test_arange()
+    test_meshgrid()
+    test_reverse()
+    test_stack()
+    test_tile()
+    test_repeat()
+    test_gather_nd()
+    test_isfinite()
+    test_isinf()
+    test_unravel_index()
+    test_sparse_to_dense()
+    test_fixed_point_multiply()
+    test_adv_index()

From fa5def3a923c61f7318677a1c052b3c87a9189f2 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Thu, 17 Dec 2020 22:31:28 +0000
Subject: [PATCH 13/36] Make Op changes only

---
 include/tvm/topi/transform.h         | 55 ++++++++++++++--------------
 python/tvm/relay/expr.py             |  7 ----
 python/tvm/relay/frontend/common.py  |  5 ---
 python/tvm/relay/loops.py            |  6 ---
 python/tvm/relay/op/_tensor.py       |  5 +--
 python/tvm/relay/op/_transform.py    |  1 -
 python/tvm/relay/op/transform.py     |  5 ---
 src/relay/op/tensor/transform.cc     |  2 -
 src/relay/transforms/type_infer.cc   |  4 +-
 tests/python/relay/test_op_level3.py | 55 +++++++++++-----------------
 10 files changed, 54 insertions(+), 91 deletions(-)

diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index c32e7ff35ad..826df0010cf 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -608,16 +608,15 @@ inline Tensor strided_slice(const Tensor& x, const Array<PrimExpr>& begin,
     for (size_t i = 0; i < src_tensor_dim; ++i) {
       out_shape.push_back(indexdiv(end[i] - begin[i], strides[i]));
     }
-    return te::compute(
-        out_shape,
-        [&](const Array<tvm::tir::Var>& indices) {
-          Array<PrimExpr> real_indices;
-          for (size_t i = 0; i < src_tensor_dim; ++i) {
-            real_indices.push_back(indices[i] * strides[i] + begin[i]);
-          }
-          return x(real_indices);
-        },
-        name, tag);
+    return te::compute(out_shape,
+                       [&](const Array<tvm::tir::Var>& indices) {
+                         Array<PrimExpr> real_indices;
+                         for (size_t i = 0; i < src_tensor_dim; ++i) {
+                           real_indices.push_back(indices[i] * strides[i] + begin[i]);
+                         }
+                         return x(real_indices);
+                       },
+                       name, tag);
   }
 
   // Setup the ranges.
@@ -1536,6 +1535,7 @@ inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& s
                            [&](const Array<Var>& i) { return (sparse_values(i)); }, name, tag));
   return result;
 }  // namespace topi
+
 /*!
  * \brief Transform the layout according to \p src_layout and \p dst_layout
  * \param src the source input.
@@ -1622,24 +1622,23 @@ inline Tensor auto_scheduler_layout_transform(const Tensor& src, const String& s
 
   parse_auto_scheduler_layout(src_layout, &src_shape, &src_axes);
   parse_auto_scheduler_layout(dst_layout, &dst_shape, &dst_axes);
-  return compute(
-      dst_shape,
-      [&](const Array<Var>& dst_indices) {
-        Array<PrimExpr> dst_indices_expr(dst_indices.begin(), dst_indices.end());
-        Array<PrimExpr> src_indices;
-        for (const std::string& src_axis : src_axes) {
-          PrimExpr src_index = 0;
-          CHECK_EQ(dst_indices_expr.size(), dst_axes.size());
-          for (size_t i = 0; i < dst_axes.size(); ++i) {
-            if (dst_axes[i] == src_axis) {
-              src_index = src_index * dst_shape[i] + dst_indices_expr[i];
-            }
-          }
-          src_indices.push_back(src_index);
-        }
-        return src(src_indices);
-      },
-      name, tag);
+  return compute(dst_shape,
+                 [&](const Array<Var>& dst_indices) {
+                   Array<PrimExpr> dst_indices_expr(dst_indices.begin(), dst_indices.end());
+                   Array<PrimExpr> src_indices;
+                   for (const std::string& src_axis : src_axes) {
+                     PrimExpr src_index = 0;
+                     CHECK_EQ(dst_indices_expr.size(), dst_axes.size());
+                     for (size_t i = 0; i < dst_axes.size(); ++i) {
+                       if (dst_axes[i] == src_axis) {
+                         src_index = src_index * dst_shape[i] + dst_indices_expr[i];
+                       }
+                     }
+                     src_indices.push_back(src_index);
+                   }
+                   return src(src_indices);
+                 },
+                 name, tag);
 }
 
 /*!
diff --git a/python/tvm/relay/expr.py b/python/tvm/relay/expr.py
index 200079beb65..7b6e4b4ccf8 100644
--- a/python/tvm/relay/expr.py
+++ b/python/tvm/relay/expr.py
@@ -499,9 +499,6 @@ def const(value, dtype=None):
     - bool maps to "bool"
     - other using the same default rule as numpy.
     """
-    if isinstance(value, tuple) and len(value) == 1:
-        value = value[0]
-
     if isinstance(value, (_base.numeric_types, (bool, list))):
         value = _np.array(value, dtype=dtype)
 
@@ -517,10 +514,6 @@ def const(value, dtype=None):
         value = _nd.array(value)
 
     if not isinstance(value, _nd.NDArray):
-        # import pdb
-
-        # pdb.set_trace()
-        print(f"Value : {value}, Type: {type(value)}")
         raise ValueError("value has to be scalar or NDArray")
 
     return Constant(value)
diff --git a/python/tvm/relay/frontend/common.py b/python/tvm/relay/frontend/common.py
index 0353dfe57b3..8c74f3a5413 100644
--- a/python/tvm/relay/frontend/common.py
+++ b/python/tvm/relay/frontend/common.py
@@ -269,11 +269,6 @@ def get_relay_op(op_name):
         # try search op in various modules
         for candidate in (_op, _op.nn, _op.image, _op.vision, _op.contrib):
             op = getattr(candidate, op_name, None)
-            # if op_name == "floor_mod" and op is not None:
-            #     import pdb
-
-            #     pdb.set_trace()
-            #     print(op)
             if op is not None:
                 break
     if not op:
diff --git a/python/tvm/relay/loops.py b/python/tvm/relay/loops.py
index ac7271e8093..6c2ab2e23d7 100644
--- a/python/tvm/relay/loops.py
+++ b/python/tvm/relay/loops.py
@@ -48,7 +48,6 @@ def while_loop(cond, loop_vars, loop_bodies):
     loop: relay.Expr
         The loop expression.
     """
-
     sb = ScopeBuilder()
     loop = _expr.Var("while_loop")
     fresh_vars = []
@@ -58,12 +57,7 @@ def while_loop(cond, loop_vars, loop_bodies):
         new_var = _expr.var(name, type_annotation=sb.type_of(loop_var))
         fresh_vars.append(new_var)
 
-    # import pdb
-
-    # pdb.set_trace()
-    print(f"Condition Fresh Vars = {cond(*fresh_vars)}")
     with sb.if_scope(cond(*fresh_vars)):
-
         sb.ret(loop(*loop_bodies(*fresh_vars)))
     with sb.else_scope():
         sb.ret(_expr.Tuple(fresh_vars))
diff --git a/python/tvm/relay/op/_tensor.py b/python/tvm/relay/op/_tensor.py
index dbe79a1209a..6fc42337132 100644
--- a/python/tvm/relay/op/_tensor.py
+++ b/python/tvm/relay/op/_tensor.py
@@ -21,10 +21,10 @@
 from tvm import topi
 from tvm.runtime import convert
 
-from .op import register_compute, register_shape_func, register_strategy
+from .op import register_compute, register_shape_func
 from .op import register_broadcast_schedule, register_injective_schedule
 from .op import register_pattern, OpPattern
-from . import strategy
+
 
 register_broadcast_schedule("log")
 register_broadcast_schedule("log2")
@@ -274,7 +274,6 @@ def elemwise_shape_func(attrs, inputs, _):
 register_shape_func("fast_exp", False, elemwise_shape_func)
 register_shape_func("fast_tanh", False, elemwise_shape_func)
 register_shape_func("fast_erf", False, elemwise_shape_func)
-register_shape_func("ceil", False, elemwise_shape_func)
 register_shape_func("floor", False, elemwise_shape_func)
 register_shape_func("log", False, elemwise_shape_func)
 register_shape_func("device_copy", False, elemwise_shape_func)
diff --git a/python/tvm/relay/op/_transform.py b/python/tvm/relay/op/_transform.py
index 20e73a40e4a..4f31dbde152 100644
--- a/python/tvm/relay/op/_transform.py
+++ b/python/tvm/relay/op/_transform.py
@@ -436,7 +436,6 @@ def argwhere_shape_func(attrs, inputs, out_ndims):
 
 _reg.register_shape_func("scatter", False, elemwise_shape_func)
 _reg.register_shape_func("scatter_add", False, elemwise_shape_func)
-# _reg.register_shape_func("sparsefillemptyrows", False, elemwise_shape_func)
 
 
 @script
diff --git a/python/tvm/relay/op/transform.py b/python/tvm/relay/op/transform.py
index ba11488763a..5b4573e1d82 100644
--- a/python/tvm/relay/op/transform.py
+++ b/python/tvm/relay/op/transform.py
@@ -1322,11 +1322,6 @@ def adv_index(inputs):
     return _make.adv_index(Tuple(inputs))
 
 
-def add2(data1, data2):
-
-    return _make.add2(data1, data2)
-
-
 def sparsefillemptyrows(sparse_indices, sparse_values, dense_shape, default_value):
 
     return _make.sparsefillemptyrows(sparse_indices, sparse_values, dense_shape, default_value)
diff --git a/src/relay/op/tensor/transform.cc b/src/relay/op/tensor/transform.cc
index 6bb3974cb32..4348a60bb5c 100644
--- a/src/relay/op/tensor/transform.cc
+++ b/src/relay/op/tensor/transform.cc
@@ -1584,7 +1584,6 @@ TVM_REGISTER_GLOBAL("relay.op._make.sparsereshape").set_body_typed(MakeSparseRes
 
 RELAY_REGISTER_OP("sparsereshape")
     .describe(R"code(Return twice of normal addition of two tensors.
-
 )code" TVM_ADD_FILELINE)
     .set_num_inputs(4)
     .add_argument("sparse_indices", "Tensor", "The first tensor")
@@ -1640,7 +1639,6 @@ TVM_REGISTER_GLOBAL("relay.op._make.sparsefillemptyrows").set_body_typed(MakeSpa
 
 RELAY_REGISTER_OP("sparsefillemptyrows")
     .describe(R"code(Return twice of normal addition of two tensors.
-
 )code" TVM_ADD_FILELINE)
     .set_num_inputs(3)
     .set_attrs_type<SparseFillEmptyRowsAttrs>()
diff --git a/src/relay/transforms/type_infer.cc b/src/relay/transforms/type_infer.cc
index 2567adb4049..327b5d1e260 100644
--- a/src/relay/transforms/type_infer.cc
+++ b/src/relay/transforms/type_infer.cc
@@ -572,7 +572,9 @@ class TypeInferencer : private ExprFunctor<Type(const Expr&)>,
     return FuncType(c->inputs, TypeCall(c->belong_to, types), td->type_vars, {});
   }
 
-  void Solve() { solver_.Solve(); }
+  void Solve() {
+    solver_.Solve();
+  }
 };
 
 class TypeInferencer::Resolver : public MixedModeMutator, PatternMutator {
diff --git a/tests/python/relay/test_op_level3.py b/tests/python/relay/test_op_level3.py
index 51c62bf4f26..de4265a5a5b 100644
--- a/tests/python/relay/test_op_level3.py
+++ b/tests/python/relay/test_op_level3.py
@@ -1016,9 +1016,6 @@ def verify_scatter_add(dshape, ishape, axis=0, dtype="float32"):
 
         ref_res = ref_scatter_add(data_np, indices_np, updates_np, axis)
         for target, ctx in tvm.testing.enabled_targets():
-            if target == "nvptx":
-                continue
-            print(target)
             for kind in ["graph", "debug"]:
                 if target == "nvptx" and dtype == "float32" and len(dshape) == 1:
                     # scatter_add 1D on GPU is implemented via atomic.
@@ -1078,8 +1075,6 @@ def verify_sparsefillemptyrows(
             sparse_indices_np, sparse_values_np, default_value_np, dense_shape_np
         )
         for target, ctx in tvm.testing.enabled_targets():
-            if target == "nvptx":
-                continue
             for kind in ["graph", "debug"]:
                 intrp = relay.create_executor(kind, ctx=ctx, target=target)
                 op_res = intrp.evaluate(func)(sparse_indices_np, sparse_values_np, default_value_np)
@@ -1094,7 +1089,6 @@ def verify_sparsefillemptyrows(
     verify_sparsefillemptyrows(
         sparse_indices_np, sparse_values_np, default_value_np, dense_shape_np
     )
-    print("Sparse Fill Empty Rows Verified !!")
 
 
 @tvm.testing.uses_gpu
@@ -1160,8 +1154,6 @@ def verify_sparsereshape(sparse_indices_np, sparse_values_np, dense_shape_np, de
             sparse_indices_np, sparse_values_np, dense_shape_np, default_value_np
         )
         for target, ctx in tvm.testing.enabled_targets():
-            if target == "nvptx":
-                continue
             for kind in ["graph", "debug"]:
                 intrp = relay.create_executor(kind, ctx=ctx, target=target)
                 op_res = intrp.evaluate(func)(
@@ -1181,33 +1173,31 @@ def verify_sparsereshape(sparse_indices_np, sparse_values_np, dense_shape_np, de
     new_shape_np = np.array([9, 4], dtype=np.int32)
     verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
 
-    # sparse_indices_np = np.array(
-    #     [[0, 0, 0, 0], [0, 0, 1, 2], [0, 1, 0, 3], [1, 0, 0, 4], [1, 2, 3, 6]], dtype=np.int32
-    # )
-    # sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
-    # prev_shape_np = np.array([2, 3, 6, 7], dtype=np.int32)
-    # new_shape_np = np.array([9, -1, 7], dtype=np.int32)
-    # verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
-
-    # sparse_indices_np = np.array([[0, 0], [0, 1], [3, 4], [4, 3], [7, 3]], dtype=np.int32)
-    # sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
-    # prev_shape_np = np.array([9, 4], dtype=np.int32)
-    # new_shape_np = np.array([2, -1, 6], dtype=np.int32)
-    # verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+    sparse_indices_np = np.array(
+        [[0, 0, 0, 0], [0, 0, 1, 2], [0, 1, 0, 3], [1, 0, 0, 4], [1, 2, 3, 6]], dtype=np.int32
+    )
+    sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    prev_shape_np = np.array([2, 3, 6, 7], dtype=np.int32)
+    new_shape_np = np.array([9, -1, 7], dtype=np.int32)
+    verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
 
-    # sparse_indices_np = np.array([[0, 0], [0, 1], [3, 4], [4, 3], [7, 3]], dtype=np.int32)
-    # sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
-    # prev_shape_np = np.array([9, 4], dtype=np.int32)
-    # new_shape_np = np.array([-1], dtype=np.int32)
-    # verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+    sparse_indices_np = np.array([[0, 0], [0, 1], [3, 4], [4, 3], [7, 3]], dtype=np.int32)
+    sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    prev_shape_np = np.array([9, 4], dtype=np.int32)
+    new_shape_np = np.array([2, -1, 6], dtype=np.int32)
+    verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
 
-    # sparse_indices_np = np.array([0, 5, 10, 20, 24], dtype=np.int32)
-    # sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
-    # prev_shape_np = np.array([25], dtype=np.int32)
-    # new_shape_np = np.array([5, 5], dtype=np.int32)
-    # verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+    sparse_indices_np = np.array([[0, 0], [0, 1], [3, 4], [4, 3], [7, 3]], dtype=np.int32)
+    sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    prev_shape_np = np.array([9, 4], dtype=np.int32)
+    new_shape_np = np.array([-1], dtype=np.int32)
+    verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
 
-    # print("Sparse Reshape Verified !!")
+    sparse_indices_np = np.array([0, 5, 10, 20, 24], dtype=np.int32)
+    sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    prev_shape_np = np.array([25], dtype=np.int32)
+    new_shape_np = np.array([5, 5], dtype=np.int32)
+    verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
 
 
 @tvm.testing.uses_gpu
@@ -1481,7 +1471,6 @@ def verify_adv_index(data_shape, index_shapes):
 
 
 if __name__ == "__main__":
-    test_scatter_add()
     test_sparsefillemptyrows()
     test_sparsereshape()
     test_cast()

From dc8d1cea766cc87c667749e9a3cb2e1112b8a25e Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Thu, 17 Dec 2020 22:33:07 +0000
Subject: [PATCH 14/36] Formatting Changes

---
 include/tvm/topi/transform.h | 923 +++++++++++++++--------------------
 1 file changed, 389 insertions(+), 534 deletions(-)

diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index 826df0010cf..a04762f28fe 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -82,18 +82,19 @@ inline Tensor expand_dims(const Tensor& x, int axis, int num_newaxis = 1,
     new_shape.push_back(x->shape[i]);
   }
 
-  return compute(new_shape,
-                 [&](const Array<Var>& indices) {
-                   Array<PrimExpr> idx;
-                   for (size_t i = 0; i < static_cast<size_t>(axis); ++i) {
-                     idx.push_back(indices[i]);
-                   }
-                   for (size_t i = axis + num_newaxis; i < indices.size(); ++i) {
-                     idx.push_back(indices[i]);
-                   }
-                   return x(idx);
-                 },
-                 name, tag);
+  return compute(
+      new_shape,
+      [&](const Array<Var>& indices) {
+        Array<PrimExpr> idx;
+        for (size_t i = 0; i < static_cast<size_t>(axis); ++i) {
+          idx.push_back(indices[i]);
+        }
+        for (size_t i = axis + num_newaxis; i < indices.size(); ++i) {
+          idx.push_back(indices[i]);
+        }
+        return x(idx);
+      },
+      name, tag);
 }
 
 /*!
@@ -136,19 +137,20 @@ inline Tensor transpose(const Tensor& x, Array<Integer> axes, std::string name =
     new_shape.push_back(x->shape[new_axis]);
   }
 
-  return compute(new_shape,
-                 [&](const Array<Var>& indices) {
-                   std::vector<PrimExpr> idx;
-                   for (size_t i = 0; i < axes.size(); ++i) {
-                     idx.push_back(1);
-                   }
-                   for (size_t i = 0; i < axes.size(); ++i) {
-                     int axis = static_cast<int>(axes[i]->value);
-                     idx[axis] = indices[i];
-                   }
-                   return x(idx);
-                 },
-                 name, tag);
+  return compute(
+      new_shape,
+      [&](const Array<Var>& indices) {
+        std::vector<PrimExpr> idx;
+        for (size_t i = 0; i < axes.size(); ++i) {
+          idx.push_back(1);
+        }
+        for (size_t i = 0; i < axes.size(); ++i) {
+          int axis = static_cast<int>(axes[i]->value);
+          idx[axis] = indices[i];
+        }
+        return x(idx);
+      },
+      name, tag);
 }
 
 /*!
@@ -244,8 +246,8 @@ inline Tensor reshape(const Tensor& x, Array<PrimExpr> newshape, std::string nam
   }
 
   if (is_empty_shape(target_shape)) {
-    return compute(target_shape, [&](const Array<Var>& indices) { return tvm::cast(x->dtype, 0); },
-                   name, tag);
+    return compute(
+        target_shape, [&](const Array<Var>& indices) { return tvm::cast(x->dtype, 0); }, name, tag);
   } else {
     return compute(
         target_shape,
@@ -351,21 +353,22 @@ inline Tensor squeeze(const Tensor& x, Array<Integer> axis, bool atleast1d = fal
     out_shape.push_back(1);
   }
 
-  return compute(out_shape,
-                 [&](const Array<Var>& indices) {
-                   Array<PrimExpr> real_indices;
-                   int flag = 0;
-                   for (size_t i = 0; i < ndim; ++i) {
-                     if (axis_set.count(static_cast<int>(i)) == 0) {
-                       real_indices.push_back(indices[i - flag]);
-                     } else {
-                       real_indices.push_back(0);
-                       flag += 1;
-                     }
-                   }
-                   return x(real_indices);
-                 },
-                 name, tag);
+  return compute(
+      out_shape,
+      [&](const Array<Var>& indices) {
+        Array<PrimExpr> real_indices;
+        int flag = 0;
+        for (size_t i = 0; i < ndim; ++i) {
+          if (axis_set.count(static_cast<int>(i)) == 0) {
+            real_indices.push_back(indices[i - flag]);
+          } else {
+            real_indices.push_back(0);
+            flag += 1;
+          }
+        }
+        return x(real_indices);
+      },
+      name, tag);
 }
 
 /*!
@@ -403,27 +406,28 @@ inline Tensor concatenate(const Array<Tensor>& inputs, int axis = 0, std::string
     out_shape.push_back(i == static_cast<size_t>(axis) ? join_size : inputs[0]->shape[i]);
   }
 
-  return compute(out_shape,
-                 [&](const Array<Var>& indices) {
-                   auto ret = inputs[0](indices);
-                   auto ind = indices[axis];
-                   for (size_t i = 0; i < inputs.size() - 1; ++i) {
-                     ind -= axis_sizes[i];
-
-                     Array<PrimExpr> idx;
-                     for (size_t i = 0; i < static_cast<size_t>(axis); ++i) {
-                       idx.push_back(indices[i]);
-                     }
-                     idx.push_back(ind);
-                     for (size_t i = axis + 1; i < indices.size(); ++i) {
-                       idx.push_back(indices[i]);
-                     }
-
-                     ret = tvm::if_then_else(ind >= 0, inputs[i + 1](idx), ret);
-                   }
-                   return ret;
-                 },
-                 name, tag);
+  return compute(
+      out_shape,
+      [&](const Array<Var>& indices) {
+        auto ret = inputs[0](indices);
+        auto ind = indices[axis];
+        for (size_t i = 0; i < inputs.size() - 1; ++i) {
+          ind -= axis_sizes[i];
+
+          Array<PrimExpr> idx;
+          for (size_t i = 0; i < static_cast<size_t>(axis); ++i) {
+            idx.push_back(indices[i]);
+          }
+          idx.push_back(ind);
+          for (size_t i = axis + 1; i < indices.size(); ++i) {
+            idx.push_back(indices[i]);
+          }
+
+          ret = tvm::if_then_else(ind >= 0, inputs[i + 1](idx), ret);
+        }
+        return ret;
+      },
+      name, tag);
 }
 
 /*!
@@ -454,19 +458,20 @@ inline Tensor stack(const Array<Tensor>& inputs, int axis = 0, std::string name
   for (size_t i = static_cast<size_t>(axis); i < static_cast<size_t>(ndim); ++i)
     out_shape.push_back(inputs[0]->shape[i]);
 
-  return compute(out_shape,
-                 [&](const Array<Var>& indices) {
-                   Array<PrimExpr> idx;
-                   for (size_t i = 0; i < indices.size(); ++i)
-                     if (i != static_cast<size_t>(axis)) idx.push_back(indices[i]);
-                   auto ind = indices[axis];
-                   auto ret = inputs[0](idx);
-                   for (int i = 0; i < static_cast<int>(inputs.size() - 1); ++i) {
-                     ret = tvm::if_then_else(ind == i + 1, inputs[i + 1](idx), ret);
-                   }
-                   return ret;
-                 },
-                 name, tag);
+  return compute(
+      out_shape,
+      [&](const Array<Var>& indices) {
+        Array<PrimExpr> idx;
+        for (size_t i = 0; i < indices.size(); ++i)
+          if (i != static_cast<size_t>(axis)) idx.push_back(indices[i]);
+        auto ind = indices[axis];
+        auto ret = inputs[0](idx);
+        for (int i = 0; i < static_cast<int>(inputs.size() - 1); ++i) {
+          ret = tvm::if_then_else(ind == i + 1, inputs[i + 1](idx), ret);
+        }
+        return ret;
+      },
+      name, tag);
 }
 
 /*!
@@ -501,7 +506,7 @@ inline Array<Tensor> split(const Tensor& x, Array<PrimExpr> split_indices, int a
     begin_ids.push_back(idx);
   }
 
-  Array<Array<PrimExpr>> out_shapes;
+  Array<Array<PrimExpr> > out_shapes;
   for (size_t i = 0; i < begin_ids.size(); ++i) {
     PrimExpr out_axis_size;
     if (i == begin_ids.size() - 1) {
@@ -524,21 +529,22 @@ inline Array<Tensor> split(const Tensor& x, Array<PrimExpr> split_indices, int a
 
   Array<Tensor> result;
   for (size_t i = 0; i < begin_ids.size(); ++i) {
-    result.push_back(compute(out_shapes[i],
-                             [&](const Array<Var>& indices) {
-                               auto begin = begin_ids[i];
-                               Array<PrimExpr> real_indices;
-                               for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
-                                 real_indices.push_back(indices[j]);
-                               }
-                               real_indices.push_back(indices[axis] + begin);
-                               for (size_t j = axis + 1; j < indices.size(); ++j) {
-                                 real_indices.push_back(indices[j]);
-                               }
-
-                               return x(real_indices);
-                             },
-                             name, tag));
+    result.push_back(compute(
+        out_shapes[i],
+        [&](const Array<Var>& indices) {
+          auto begin = begin_ids[i];
+          Array<PrimExpr> real_indices;
+          for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
+            real_indices.push_back(indices[j]);
+          }
+          real_indices.push_back(indices[axis] + begin);
+          for (size_t j = axis + 1; j < indices.size(); ++j) {
+            real_indices.push_back(indices[j]);
+          }
+
+          return x(real_indices);
+        },
+        name, tag));
   }
 
   return result;
@@ -566,15 +572,16 @@ inline te::Tensor dynamic_strided_slice(const te::Tensor& x, const te::Tensor& b
   for (int64_t i = 0; i < src_tensor_dim; ++i) {
     out_shape.push_back(tvm::tir::Var("dim"));
   }
-  return te::compute(out_shape,
-                     [&](const Array<tvm::tir::Var>& indices) {
-                       Array<PrimExpr> real_indices;
-                       for (int32_t i = 0; i < src_tensor_dim; ++i) {
-                         real_indices.push_back(indices[i] * strides(i) + begin(i));
-                       }
-                       return x(real_indices);
-                     },
-                     name, tag);
+  return te::compute(
+      out_shape,
+      [&](const Array<tvm::tir::Var>& indices) {
+        Array<PrimExpr> real_indices;
+        for (int32_t i = 0; i < src_tensor_dim; ++i) {
+          real_indices.push_back(indices[i] * strides(i) + begin(i));
+        }
+        return x(real_indices);
+      },
+      name, tag);
 }
 
 /*!
@@ -608,15 +615,16 @@ inline Tensor strided_slice(const Tensor& x, const Array<PrimExpr>& begin,
     for (size_t i = 0; i < src_tensor_dim; ++i) {
       out_shape.push_back(indexdiv(end[i] - begin[i], strides[i]));
     }
-    return te::compute(out_shape,
-                       [&](const Array<tvm::tir::Var>& indices) {
-                         Array<PrimExpr> real_indices;
-                         for (size_t i = 0; i < src_tensor_dim; ++i) {
-                           real_indices.push_back(indices[i] * strides[i] + begin[i]);
-                         }
-                         return x(real_indices);
-                       },
-                       name, tag);
+    return te::compute(
+        out_shape,
+        [&](const Array<tvm::tir::Var>& indices) {
+          Array<PrimExpr> real_indices;
+          for (size_t i = 0; i < src_tensor_dim; ++i) {
+            real_indices.push_back(indices[i] * strides[i] + begin[i]);
+          }
+          return x(real_indices);
+        },
+        name, tag);
   }
 
   // Setup the ranges.
@@ -695,15 +703,16 @@ inline Tensor strided_slice(const Tensor& x, const Array<PrimExpr>& begin,
     out_shape.push_back(slice_size);
   }
 
-  return compute(out_shape,
-                 [&](const Array<Var>& indices) {
-                   Array<PrimExpr> real_indices;
-                   for (size_t i = 0; i < src_tensor_dim; ++i) {
-                     real_indices.push_back(indices[i] * strides_expr[i] + begin_expr[i]);
-                   }
-                   return x(real_indices);
-                 },
-                 name, tag);
+  return compute(
+      out_shape,
+      [&](const Array<Var>& indices) {
+        Array<PrimExpr> real_indices;
+        for (size_t i = 0; i < src_tensor_dim; ++i) {
+          real_indices.push_back(indices[i] * strides_expr[i] + begin_expr[i]);
+        }
+        return x(real_indices);
+      },
+      name, tag);
 }
 
 /*!
@@ -770,12 +779,13 @@ inline Tensor take(const Tensor& a, const Tensor& indices, std::string mode = "c
   }
 
   if (mode == "clip") {
-    return compute(out_shape,
-                   [&](const Array<Var>& out_index) {
-                     auto idx = tvm::min(tvm::max(0, indices(out_index)), a_size - 1);
-                     return a(UnravelIndex(idx, a_shape));
-                   },
-                   name, tag);
+    return compute(
+        out_shape,
+        [&](const Array<Var>& out_index) {
+          auto idx = tvm::min(tvm::max(0, indices(out_index)), a_size - 1);
+          return a(UnravelIndex(idx, a_shape));
+        },
+        name, tag);
   } else if (mode == "fast") {
     LOG(WARNING) << "Fast mode segfaults when there are out-of-bounds indices. "
                     "Make sure input indices are in bound";
@@ -784,12 +794,13 @@ inline Tensor take(const Tensor& a, const Tensor& indices, std::string mode = "c
         [&](const Array<Var>& out_index) { return a(UnravelIndex(indices(out_index), a_shape)); },
         name, tag);
   } else {  // mode == "wrap"
-    return compute(out_shape,
-                   [&](const Array<Var>& out_index) {
-                     auto idx = truncmod(truncmod(indices(out_index), a_size) + a_size, a_size);
-                     return a(UnravelIndex(idx, a_shape));
-                   },
-                   name, tag);
+    return compute(
+        out_shape,
+        [&](const Array<Var>& out_index) {
+          auto idx = truncmod(truncmod(indices(out_index), a_size) + a_size, a_size);
+          return a(UnravelIndex(idx, a_shape));
+        },
+        name, tag);
   }
 }
 
@@ -813,18 +824,19 @@ inline Tensor sequence_mask(const Tensor& data, const Tensor& valid_length, doub
   auto length_dim = data->shape[axis];
   auto batch_dim = data->shape[1 - axis];
   Array<PrimExpr> out_shape = data->shape;
-  Tensor out = compute(out_shape,
-                       [&](const Array<Var>& out_index) {
-                         Array<PrimExpr> len_index;
-                         auto tid = out_index[axis];
-                         auto bid = out_index[1 - axis];
-                         len_index.push_back(bid);
-                         PrimExpr ret = tvm::if_then_else(
-                             tvm::cast(valid_length->dtype, tid) >= valid_length(len_index),
-                             tvm::tir::make_const(data->dtype, mask_value), data(out_index));
-                         return ret;
-                       },
-                       name, tag);
+  Tensor out = compute(
+      out_shape,
+      [&](const Array<Var>& out_index) {
+        Array<PrimExpr> len_index;
+        auto tid = out_index[axis];
+        auto bid = out_index[1 - axis];
+        len_index.push_back(bid);
+        PrimExpr ret =
+            tvm::if_then_else(tvm::cast(valid_length->dtype, tid) >= valid_length(len_index),
+                              tvm::tir::make_const(data->dtype, mask_value), data(out_index));
+        return ret;
+      },
+      name, tag);
   return out;
 }
 
@@ -862,64 +874,66 @@ inline Tensor take(const Tensor& a, const Tensor& indices, int axis, std::string
     }
   }
   if (mode == "clip") {
-    return compute(out_shape,
-                   [&](const Array<Var>& out_index) {
-                     Array<PrimExpr> indices_position;
-                     for (size_t j = axis; j < static_cast<size_t>(axis + indices_len); ++j) {
-                       indices_position.push_back(out_index[j]);
-                     }
-                     Array<PrimExpr> real_indices;
-                     for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
-                       real_indices.push_back(out_index[j]);
-                     }
-                     auto idx = tvm::min(tvm::max(0, indices(indices_position)), axis_dim - 1);
-                     real_indices.push_back(idx);
-                     for (size_t j = axis + indices_len; j < out_index.size(); ++j) {
-                       real_indices.push_back(out_index[j]);
-                     }
-                     return a(real_indices);
-                   },
-                   name, tag);
+    return compute(
+        out_shape,
+        [&](const Array<Var>& out_index) {
+          Array<PrimExpr> indices_position;
+          for (size_t j = axis; j < static_cast<size_t>(axis + indices_len); ++j) {
+            indices_position.push_back(out_index[j]);
+          }
+          Array<PrimExpr> real_indices;
+          for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
+            real_indices.push_back(out_index[j]);
+          }
+          auto idx = tvm::min(tvm::max(0, indices(indices_position)), axis_dim - 1);
+          real_indices.push_back(idx);
+          for (size_t j = axis + indices_len; j < out_index.size(); ++j) {
+            real_indices.push_back(out_index[j]);
+          }
+          return a(real_indices);
+        },
+        name, tag);
   } else if (mode == "fast") {
     LOG(WARNING) << "Fast mode segfaults when there are out-of-bounds indices. "
                     "Make sure input indices are in bound";
-    return compute(out_shape,
-                   [&](const Array<Var>& out_index) {
-                     Array<PrimExpr> indices_position;
-                     for (size_t j = axis; j < static_cast<size_t>(axis + indices_len); ++j) {
-                       indices_position.push_back(out_index[j]);
-                     }
-                     Array<PrimExpr> real_indices;
-                     for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
-                       real_indices.push_back(out_index[j]);
-                     }
-                     real_indices.push_back(indices(indices_position));
-                     for (size_t j = axis + indices_len; j < out_index.size(); ++j) {
-                       real_indices.push_back(out_index[j]);
-                     }
-                     return a(real_indices);
-                   },
-                   name, tag);
+    return compute(
+        out_shape,
+        [&](const Array<Var>& out_index) {
+          Array<PrimExpr> indices_position;
+          for (size_t j = axis; j < static_cast<size_t>(axis + indices_len); ++j) {
+            indices_position.push_back(out_index[j]);
+          }
+          Array<PrimExpr> real_indices;
+          for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
+            real_indices.push_back(out_index[j]);
+          }
+          real_indices.push_back(indices(indices_position));
+          for (size_t j = axis + indices_len; j < out_index.size(); ++j) {
+            real_indices.push_back(out_index[j]);
+          }
+          return a(real_indices);
+        },
+        name, tag);
   } else {  // mode == "wrap"
-    return compute(out_shape,
-                   [&](const Array<Var>& out_index) {
-                     Array<PrimExpr> indices_position;
-                     for (size_t j = axis; j < static_cast<size_t>(axis + indices_len); ++j) {
-                       indices_position.push_back(out_index[j]);
-                     }
-                     Array<PrimExpr> real_indices;
-                     for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
-                       real_indices.push_back(out_index[j]);
-                     }
-                     auto idx = truncmod(truncmod(indices(indices_position), axis_dim) + axis_dim,
-                                         axis_dim);
-                     real_indices.push_back(idx);
-                     for (size_t j = axis + indices_len; j < out_index.size(); ++j) {
-                       real_indices.push_back(out_index[j]);
-                     }
-                     return a(real_indices);
-                   },
-                   name, tag);
+    return compute(
+        out_shape,
+        [&](const Array<Var>& out_index) {
+          Array<PrimExpr> indices_position;
+          for (size_t j = axis; j < static_cast<size_t>(axis + indices_len); ++j) {
+            indices_position.push_back(out_index[j]);
+          }
+          Array<PrimExpr> real_indices;
+          for (size_t j = 0; j < static_cast<size_t>(axis); ++j) {
+            real_indices.push_back(out_index[j]);
+          }
+          auto idx = truncmod(truncmod(indices(indices_position), axis_dim) + axis_dim, axis_dim);
+          real_indices.push_back(idx);
+          for (size_t j = axis + indices_len; j < out_index.size(); ++j) {
+            real_indices.push_back(out_index[j]);
+          }
+          return a(real_indices);
+        },
+        name, tag);
   }
 }
 
@@ -995,19 +1009,20 @@ inline Tensor repeat(const Tensor& x, int repeats, int axis, std::string name =
     new_shape.push_back(x->shape[i]);
   }
 
-  return compute(new_shape,
-                 [&](const Array<Var>& indices) {
-                   Array<PrimExpr> idx;
-                   for (size_t i = 0; i < static_cast<size_t>(axis); ++i) {
-                     idx.push_back(indices[i]);
-                   }
-                   idx.push_back(indexdiv(indices[axis], repeats));
-                   for (size_t i = axis + 1; i < indices.size(); ++i) {
-                     idx.push_back(indices[i]);
-                   }
-                   return x(idx);
-                 },
-                 name, tag);
+  return compute(
+      new_shape,
+      [&](const Array<Var>& indices) {
+        Array<PrimExpr> idx;
+        for (size_t i = 0; i < static_cast<size_t>(axis); ++i) {
+          idx.push_back(indices[i]);
+        }
+        idx.push_back(indexdiv(indices[axis], repeats));
+        for (size_t i = axis + 1; i < indices.size(); ++i) {
+          idx.push_back(indices[i]);
+        }
+        return x(idx);
+      },
+      name, tag);
 }
 
 /*!
@@ -1045,22 +1060,22 @@ inline Tensor tile(const Tensor& x, Array<Integer> reps, std::string name = "T_t
   for (size_t i = 0; i < tdim; ++i) new_shape.push_back(data_shape[i] * reps_shape[i]);
 
   if (is_empty_shape(new_shape)) {
-    return compute(new_shape, [&](const Array<Var>& indices) { return tvm::cast(x->dtype, 0); },
-                   name, tag);
+    return compute(
+        new_shape, [&](const Array<Var>& indices) { return tvm::cast(x->dtype, 0); }, name, tag);
   } else {
-    return compute(new_shape,
-                   [&](const Array<Var>& indices) {
-                     Array<PrimExpr> idx;
-                     if (ndim >= rdim) {
-                       for (size_t i = 0; i < ndim; ++i)
-                         idx.push_back(indexmod(indices[i], x->shape[i]));
-                     } else {
-                       for (size_t i = 0; i < ndim; ++i)
-                         idx.push_back(indexmod(indices[rdim - ndim + i], x->shape[i]));
-                     }
-                     return x(idx);
-                   },
-                   name, tag);
+    return compute(
+        new_shape,
+        [&](const Array<Var>& indices) {
+          Array<PrimExpr> idx;
+          if (ndim >= rdim) {
+            for (size_t i = 0; i < ndim; ++i) idx.push_back(indexmod(indices[i], x->shape[i]));
+          } else {
+            for (size_t i = 0; i < ndim; ++i)
+              idx.push_back(indexmod(indices[rdim - ndim + i], x->shape[i]));
+          }
+          return x(idx);
+        },
+        name, tag);
   }
 }
 
@@ -1079,24 +1094,25 @@ inline Tensor dyn_tile(const Tensor& x, Array<PrimExpr> new_shape, size_t rdim,
                        std::string name = "T_tile", std::string tag = kBroadcast) {
   size_t ndim = x->shape.size();
   if (is_empty_shape(new_shape)) {
-    return compute(new_shape, [&](const Array<Var>& indices) { return tvm::cast(x->dtype, 0); },
-                   name, tag);
+    return compute(
+        new_shape, [&](const Array<Var>& indices) { return tvm::cast(x->dtype, 0); }, name, tag);
   } else {
-    return compute(new_shape,
-                   [&](const Array<Var>& indices) {
-                     Array<PrimExpr> idx;
-                     if (ndim >= rdim) {
-                       for (size_t i = 0; i < ndim; ++i) {
-                         idx.push_back(indexmod(indices[i], x->shape[i]));
-                       }
-                     } else {
-                       for (size_t i = 0; i < ndim; ++i) {
-                         idx.push_back(indexmod(indices[rdim - ndim + i], x->shape[i]));
-                       }
-                     }
-                     return x(idx);
-                   },
-                   name, tag);
+    return compute(
+        new_shape,
+        [&](const Array<Var>& indices) {
+          Array<PrimExpr> idx;
+          if (ndim >= rdim) {
+            for (size_t i = 0; i < ndim; ++i) {
+              idx.push_back(indexmod(indices[i], x->shape[i]));
+            }
+          } else {
+            for (size_t i = 0; i < ndim; ++i) {
+              idx.push_back(indexmod(indices[rdim - ndim + i], x->shape[i]));
+            }
+          }
+          return x(idx);
+        },
+        name, tag);
   }
 }
 
@@ -1128,23 +1144,24 @@ inline Tensor gather(const Tensor& data, int axis, const Tensor& indices,
     out_shape.push_back(indices->shape[i]);
   }
 
-  return compute(out_shape,
-                 [&](const Array<Var>& out_index) {
-                   Array<PrimExpr> indices_position;
-                   for (size_t i = 0; i < ndim_i; ++i) {
-                     indices_position.push_back(out_index[i]);
-                   }
-                   Array<PrimExpr> real_indices;
-                   for (size_t i = 0; i < ndim_i; ++i) {
-                     if (i == (size_t)axis) {
-                       real_indices.push_back(indices(indices_position));
-                     } else {
-                       real_indices.push_back(indices_position[i]);
-                     }
-                   }
-                   return data(real_indices);
-                 },
-                 name, tag);
+  return compute(
+      out_shape,
+      [&](const Array<Var>& out_index) {
+        Array<PrimExpr> indices_position;
+        for (size_t i = 0; i < ndim_i; ++i) {
+          indices_position.push_back(out_index[i]);
+        }
+        Array<PrimExpr> real_indices;
+        for (size_t i = 0; i < ndim_i; ++i) {
+          if (i == (size_t)axis) {
+            real_indices.push_back(indices(indices_position));
+          } else {
+            real_indices.push_back(indices_position[i]);
+          }
+        }
+        return data(real_indices);
+      },
+      name, tag);
 }
 
 /*!
@@ -1357,185 +1374,18 @@ inline Array<Tensor> meshgrid(const Array<Tensor>& inputs, const std::string& in
   }
   Array<Tensor> result;
   for (size_t i = 0; i < inputs.size(); ++i) {
-    result.push_back(compute(out_shape,
-                             [&](const Array<Var>& indices) {
-                               const int src_index = (cartesian_indexing && i < 2) ? 1 - i : i;
-                               Array<PrimExpr> real_indices = {indices[src_index]};
-                               return inputs[i](real_indices);
-                             },
-                             name, tag));
-  }
-  return result;
-}
-
-inline Array<Tensor> SparseFillEmptyRows(const Tensor& sparse_indices, const Tensor& sparse_values,
-                                         const Tensor& default_value,
-                                         const Array<Integer>& dense_shape,
-                                         const std::string name = "T_sparsefillemptyrows",
-                                         std::string tag = kInjective) {
-  Array<Tensor> result;
-  Array<PrimExpr> sp_ordered_output_shape;
-  sp_ordered_output_shape.push_back(dense_shape[0] + sparse_indices->shape[0]);
-  if (sparse_indices->shape.size() > 1) {
-    sp_ordered_output_shape.push_back(sparse_indices->shape[1]);
+    result.push_back(compute(
+        out_shape,
+        [&](const Array<Var>& indices) {
+          const int src_index = (cartesian_indexing && i < 2) ? 1 - i : i;
+          Array<PrimExpr> real_indices = {indices[src_index]};
+          return inputs[i](real_indices);
+        },
+        name, tag));
   }
-  int num_rows = static_cast<int>(dense_shape[0]) + GetConstInt(sparse_indices->shape[0]);
-  int num_cols = GetConstInt(sparse_indices->shape[1]);
-  std::vector<std::vector<PrimExpr>> sp_ordered_output(
-      num_rows, std::vector<PrimExpr>(num_cols, PrimExpr(-1)));
-
-  // std::vector<std::vector<int>> vec(100, std::vector<int>(400, 0));
-  std::vector<int> missing_indices;
-  std::vector<int> current_missing_index{0};
-  std::vector<int> total_missing_indices{0};
-  auto empty_row_indicator =
-      tvm::te::compute(Array<PrimExpr>{dense_shape[0]}, [&](const Array<Var>& indices) {
-        // for (int i = 0; i < GetConstInt(sparse_indices->shape[0]); ++i) {
-        //   sparse_indices[i]
-        // }
-        PrimExpr current_number = sparse_indices[indices[0] - total_missing_indices[0]];
-
-        bool cur_flag = true;
-        for (; cur_flag;) {
-          PrimExpr ret = if_then_else(current_number <= current_missing_index[0], 1, -1);
-          if (ret.as<IntImmNode>()->value == 1) {
-            PrimExpr ret2 = if_then_else(current_number == current_missing_index[0], 1, -1);
-            if (ret2.as<IntImmNode>()->value == 1) {
-              current_missing_index[0]++;
-              return PrimExpr(Bool(1));
-            } else {
-              current_number += 1;
-            }
-          } else {
-            total_missing_indices[0]++;
-          }
-        }
-        return PrimExpr(Bool(1));
-      });
-  result.push_back(compute(sp_ordered_output_shape,
-                           [&](const Array<Var>& indices) {
-                             PrimExpr ret = -1;
-                             //  ret += missing_index;
-                             //  int missing_index = 0;
-                             // PrimExpr current_missing_index = 0;
-                             // PrimExpr count_missing_indices = 0;
-                             // for (int i = 0; i < GetConstInt(sparse_indices->shape[0]); ++i)
-                             // {
-                             //   PrimExpr is_missing_index = if_then_else(sparse_indices[i][0]
-                             //   <= current_missing_index,
-                             //                                            current_missing_index,
-                             //                                            -1);
-                             //   if (const IntImmNode* op = is_missing_index.as<IntImmNode>())
-                             //   {
-                             //     if (op->value == -1) {
-                             //       PrimExpr on_current_indices =
-                             //           if_then_else(indices[0] == i + count_missing_indices,
-                             //           current_missing_index, -1);
-                             //       if (const IntImmNode* op =
-                             //       is_missing_index.as<IntImmNode>())
-                             //       {
-                             //         if (op->value == -1) {
-                             //           continue;
-                             //         } else {
-                             //           for (int j = 0; j < 6; ++j) {
-                             //             break;
-                             //           }
-                             //         }
-                             //       }
-                             //       count_missing_indices += 1;
-                             //     } else {
-                             //       PrimExpr current_missing_index =
-                             //           if_then_else(sparse_indices[i][0] ==
-                             //           current_missing_index,
-                             //                        current_missing_index + 1,
-                             //                        current_missing_index);
-                             //     }
-                             //   }
-                             // }
-                             return ret;
-                           },
-                           name, tag));
-  result.push_back(compute(Array<PrimExpr>{dense_shape[0]},
-                           [&](const Array<Var>& i) {
-                             PrimExpr ret = Bool(1);
-                             return ret;
-                           },
-                           name, tag));
   return result;
 }
 
-inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& sparse_values,
-                                   const Tensor& prev_shape, const Tensor& new_shape,
-                                   const std::string name = "T_sparsereshape",
-                                   std::string tag = kInjective) {
-  Array<Tensor> result;
-  Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0], new_shape->shape[0]};
-  std::vector<PrimExpr> multipliers(GetConstInt(prev_shape->shape[0]), 1);
-  std::vector<PrimExpr> dividers(GetConstInt(new_shape->shape[0]), 1);
-
-  tvm::te::compute(Array<PrimExpr>{1}, [&](const Array<Var>& indices) {
-    tvm::PrimExpr total_ele = prev_shape[0];
-    for (int i = GetConstInt(prev_shape->shape[0]) - 2; i >= 0; --i) {
-      multipliers[i] = prev_shape[i + 1] * multipliers[i + 1];
-      total_ele *= prev_shape[i + 1];
-    }
-    PrimExpr division_total_ele = 1;
-    for (int i = 0; i < GetConstInt(new_shape->shape[0]); ++i) {
-      division_total_ele *= if_then_else(new_shape[i] != -1, new_shape[i], 1);
-    }
-    for (int i = GetConstInt(new_shape->shape[0]) - 2; i >= 0; --i) {
-      dividers[i] = dividers[i + 1] * if_then_else(new_shape[i + 1] != -1, new_shape[i + 1],
-                                                   div(total_ele, division_total_ele));
-    }
-    return PrimExpr(1);
-  });
-
-  result.push_back(compute(new_sparse_indices_shape,
-                           [&](const Array<Var>& indices) {
-                             PrimExpr flattened_idx = 0;
-                             if (sparse_indices->shape.size() == 1) {
-                               flattened_idx += sparse_indices[indices[0]];
-                             } else {
-                               for (int k = 0; k < GetConstInt(sparse_indices->shape[1]); k++) {
-                                 flattened_idx += (sparse_indices[indices[0]][k] * multipliers[k]);
-                               }
-                             }
-                             Array<PrimExpr> new_sparse_indices;
-                             if (GetConstInt(new_shape->shape[0]) != 1) {
-                               for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
-                                 new_sparse_indices.push_back(floordiv(flattened_idx, dividers[i]));
-                                 flattened_idx = floormod(flattened_idx, dividers[i]);
-                               }
-                               PrimExpr ret = -1;
-
-                               for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
-                                 //  auto ret = tir::Select(indices[1] == i, new_sparse_indices[i],
-                                 //  -1);
-                                 if (indices.size() == 1) {
-                                   return new_sparse_indices[0];
-                                 } else {
-                                   ret = if_then_else(indices[1] == i, new_sparse_indices[i], ret);
-                                   //  PrimExpr cond = (ret == -1);
-                                   if (const IntImmNode* op = ret.as<IntImmNode>()) {
-                                     if (op->value == -1) {
-                                       continue;
-                                     } else {
-                                       break;
-                                     }
-                                   }
-                                 }
-                               }
-                               return ret;
-                             } else {
-                               return flattened_idx;
-                             }
-                           },
-                           name, tag));
-  result.push_back(compute(sparse_values->shape,
-                           [&](const Array<Var>& i) { return (sparse_values(i)); }, name, tag));
-  return result;
-}  // namespace topi
-
 /*!
  * \brief Transform the layout according to \p src_layout and \p dst_layout
  * \param src the source input.
@@ -1565,13 +1415,14 @@ inline Tensor layout_transform(const Tensor& src, const std::string& src_layout,
 
   Array<PrimExpr> dst_shape = layout_converter.ForwardShape(src->shape);
 
-  return compute(dst_shape,
-                 [&](const Array<Var>& dst_indices) {
-                   Array<PrimExpr> dst_indices_expr(dst_indices.begin(), dst_indices.end());
-                   Array<PrimExpr> src_indices = layout_converter.BackwardIndex(dst_indices_expr);
-                   return src(src_indices);
-                 },
-                 name, tag);
+  return compute(
+      dst_shape,
+      [&](const Array<Var>& dst_indices) {
+        Array<PrimExpr> dst_indices_expr(dst_indices.begin(), dst_indices.end());
+        Array<PrimExpr> src_indices = layout_converter.BackwardIndex(dst_indices_expr);
+        return src(src_indices);
+      },
+      name, tag);
 }
 
 /*! \brief Utility function for auto_scheduler_layout_transform */
@@ -1622,23 +1473,24 @@ inline Tensor auto_scheduler_layout_transform(const Tensor& src, const String& s
 
   parse_auto_scheduler_layout(src_layout, &src_shape, &src_axes);
   parse_auto_scheduler_layout(dst_layout, &dst_shape, &dst_axes);
-  return compute(dst_shape,
-                 [&](const Array<Var>& dst_indices) {
-                   Array<PrimExpr> dst_indices_expr(dst_indices.begin(), dst_indices.end());
-                   Array<PrimExpr> src_indices;
-                   for (const std::string& src_axis : src_axes) {
-                     PrimExpr src_index = 0;
-                     CHECK_EQ(dst_indices_expr.size(), dst_axes.size());
-                     for (size_t i = 0; i < dst_axes.size(); ++i) {
-                       if (dst_axes[i] == src_axis) {
-                         src_index = src_index * dst_shape[i] + dst_indices_expr[i];
-                       }
-                     }
-                     src_indices.push_back(src_index);
-                   }
-                   return src(src_indices);
-                 },
-                 name, tag);
+  return compute(
+      dst_shape,
+      [&](const Array<Var>& dst_indices) {
+        Array<PrimExpr> dst_indices_expr(dst_indices.begin(), dst_indices.end());
+        Array<PrimExpr> src_indices;
+        for (const std::string& src_axis : src_axes) {
+          PrimExpr src_index = 0;
+          CHECK_EQ(dst_indices_expr.size(), dst_axes.size());
+          for (size_t i = 0; i < dst_axes.size(); ++i) {
+            if (dst_axes[i] == src_axis) {
+              src_index = src_index * dst_shape[i] + dst_indices_expr[i];
+            }
+          }
+          src_indices.push_back(src_index);
+        }
+        return src(src_indices);
+      },
+      name, tag);
 }
 
 /*!
@@ -1653,16 +1505,17 @@ inline Tensor shape(const Tensor& src, DataType dtype, const std::string name =
                     const std::string tag = kInjective) {
   int ndim = static_cast<int>(src->shape.size());
   Array<PrimExpr> out_shape{ndim};
-  return compute(out_shape,
-                 [&](const Array<Var>& indices) {
-                   auto idx = indices[0];
-                   PrimExpr ret = 0;
-                   for (int i = 0; i < ndim; ++i) {
-                     ret = tvm::if_then_else(idx == i, src->shape[i], ret);
-                   }
-                   return tvm::cast(dtype, ret);
-                 },
-                 name, tag);
+  return compute(
+      out_shape,
+      [&](const Array<Var>& indices) {
+        auto idx = indices[0];
+        PrimExpr ret = 0;
+        for (int i = 0; i < ndim; ++i) {
+          ret = tvm::if_then_else(idx == i, src->shape[i], ret);
+        }
+        return tvm::cast(dtype, ret);
+      },
+      name, tag);
 }
 
 /*!
@@ -1678,15 +1531,16 @@ inline Tensor ndarray_size(const Tensor& src, const DataType& dtype,
                            const std::string& tag = kInjective) {
   int ndim = static_cast<int>(src->shape.size());
   Array<PrimExpr> out_ndarray_size = {};
-  return compute(out_ndarray_size,
-                 [&](const Array<Var>& indices) {
-                   PrimExpr ret = 1;
-                   for (int i = 0; i < ndim; ++i) {
-                     ret *= src->shape[i];
-                   }
-                   return tvm::cast(dtype, ret);
-                 },
-                 name, tag);
+  return compute(
+      out_ndarray_size,
+      [&](const Array<Var>& indices) {
+        PrimExpr ret = 1;
+        for (int i = 0; i < ndim; ++i) {
+          ret *= src->shape[i];
+        }
+        return tvm::cast(dtype, ret);
+      },
+      name, tag);
 }
 
 /*!
@@ -1722,22 +1576,22 @@ inline Tensor one_hot(const Tensor& indices, const PrimExpr on_value, const Prim
 
   PrimExpr on_value_cast = cast(dtype, on_value);
   PrimExpr off_value_cast = cast(dtype, off_value);
-  return compute(oshape,
-                 [&](const Array<Var>& iter_vars) {
-                   Array<Var> indices_indices;
-                   for (size_t i = 0; i < iter_vars.size(); i++) {
-                     if (static_cast<int>(i) == true_axis) {
-                       continue;
-                     }
-
-                     indices_indices.push_back(iter_vars[i]);
-                   }
-
-                   auto idx = iter_vars[true_axis];
-                   return tir::Select(indices(indices_indices) == idx, on_value_cast,
-                                      off_value_cast);
-                 },
-                 name, tag);
+  return compute(
+      oshape,
+      [&](const Array<Var>& iter_vars) {
+        Array<Var> indices_indices;
+        for (size_t i = 0; i < iter_vars.size(); i++) {
+          if (static_cast<int>(i) == true_axis) {
+            continue;
+          }
+
+          indices_indices.push_back(iter_vars[i]);
+        }
+
+        auto idx = iter_vars[true_axis];
+        return tir::Select(indices(indices_indices) == idx, on_value_cast, off_value_cast);
+      },
+      name, tag);
 }
 
 /*!
@@ -1764,29 +1618,29 @@ inline Tensor sparse_to_dense(const Tensor& sparse_indices, const Array<PrimExpr
   for (auto l : output_shape) {
     oshape.push_back(l);
   }
-  return compute(oshape,
-                 [&](const Array<Var>& indices) {
-                   PrimExpr ret = default_value;
-                   if (0 == rank_sparse_indices) {
-                     ret = if_then_else(indices[0] == sparse_indices[0], sparse_values[0], ret);
-                   } else if (1 == rank_sparse_indices) {
-                     for (int j = 0; j < GetConstInt(sparse_indices->shape[0]); j++) {
-                       ret = if_then_else(indices[0] == sparse_indices[j], sparse_values[j], ret);
-                     }
-                   } else {
-                     for (int j = 0; j < GetConstInt(sparse_indices->shape[0]); j++) {
-                       PrimExpr aggregate_condition;
-                       for (int k = 0; k < GetConstInt(sparse_indices->shape[1]); k++) {
-                         PrimExpr comparision = indices[k] == sparse_indices[j][k];
-                         aggregate_condition =
-                             0 == k ? comparision : aggregate_condition && comparision;
-                       }
-                       ret = if_then_else(aggregate_condition, sparse_values[j], ret);
-                     }
-                   }
-                   return ret;
-                 },
-                 name, tag);
+  return compute(
+      oshape,
+      [&](const Array<Var>& indices) {
+        PrimExpr ret = default_value;
+        if (0 == rank_sparse_indices) {
+          ret = if_then_else(indices[0] == sparse_indices[0], sparse_values[0], ret);
+        } else if (1 == rank_sparse_indices) {
+          for (int j = 0; j < GetConstInt(sparse_indices->shape[0]); j++) {
+            ret = if_then_else(indices[0] == sparse_indices[j], sparse_values[j], ret);
+          }
+        } else {
+          for (int j = 0; j < GetConstInt(sparse_indices->shape[0]); j++) {
+            PrimExpr aggregate_condition;
+            for (int k = 0; k < GetConstInt(sparse_indices->shape[1]); k++) {
+              PrimExpr comparision = indices[k] == sparse_indices[j][k];
+              aggregate_condition = 0 == k ? comparision : aggregate_condition && comparision;
+            }
+            ret = if_then_else(aggregate_condition, sparse_values[j], ret);
+          }
+        }
+        return ret;
+      },
+      name, tag);
 }
 
 /*!
@@ -1907,24 +1761,25 @@ inline Tensor adv_index(const Tensor& data, const Array<Tensor>& indices,
     oshape.push_back(data->shape[i]);
   }
 
-  return compute(oshape,
-                 [&](const Array<Var>& iter_var) {
-                   Array<PrimExpr> tensor_indices;
-                   for (size_t i = 0; i < broadcast_shape.size(); ++i) {
-                     tensor_indices.push_back(iter_var[i]);
-                   }
-
-                   Array<PrimExpr> real_indices;
-                   for (size_t i = 0; i < bindices.size(); ++i) {
-                     real_indices.push_back(bindices[i](tensor_indices));
-                   }
-                   for (size_t i = broadcast_shape.size(); i < iter_var.size(); ++i) {
-                     real_indices.push_back(iter_var[i]);
-                   }
-
-                   return data(real_indices);
-                 },
-                 name, tag);
+  return compute(
+      oshape,
+      [&](const Array<Var>& iter_var) {
+        Array<PrimExpr> tensor_indices;
+        for (size_t i = 0; i < broadcast_shape.size(); ++i) {
+          tensor_indices.push_back(iter_var[i]);
+        }
+
+        Array<PrimExpr> real_indices;
+        for (size_t i = 0; i < bindices.size(); ++i) {
+          real_indices.push_back(bindices[i](tensor_indices));
+        }
+        for (size_t i = broadcast_shape.size(); i < iter_var.size(); ++i) {
+          real_indices.push_back(iter_var[i]);
+        }
+
+        return data(real_indices);
+      },
+      name, tag);
 }
 
 }  // namespace topi

From 2d48888b292a5967570c38d58d72dbb0529c80f9 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Thu, 17 Dec 2020 22:45:17 +0000
Subject: [PATCH 15/36] Only Transform changes

---
 include/tvm/topi/transform.h | 167 +++++++++++++++++++++++++++++++++++
 1 file changed, 167 insertions(+)

diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index a04762f28fe..3f2c22cf024 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -1386,6 +1386,173 @@ inline Array<Tensor> meshgrid(const Array<Tensor>& inputs, const std::string& in
   return result;
 }
 
+inline Array<Tensor> SparseFillEmptyRows(const Tensor& sparse_indices, const Tensor& sparse_values,
+                                         const Tensor& default_value,
+                                         const Array<Integer>& dense_shape,
+                                         const std::string name = "T_sparsefillemptyrows",
+                                         std::string tag = kInjective) {
+  Array<Tensor> result;
+  Array<PrimExpr> sp_ordered_output_shape;
+  sp_ordered_output_shape.push_back(dense_shape[0] + sparse_indices->shape[0]);
+  if (sparse_indices->shape.size() > 1) {
+    sp_ordered_output_shape.push_back(sparse_indices->shape[1]);
+  }
+  int num_rows = static_cast<int>(dense_shape[0]) + GetConstInt(sparse_indices->shape[0]);
+  int num_cols = GetConstInt(sparse_indices->shape[1]);
+  std::vector<std::vector<PrimExpr>> sp_ordered_output(
+      num_rows, std::vector<PrimExpr>(num_cols, PrimExpr(-1)));
+
+  // std::vector<std::vector<int>> vec(100, std::vector<int>(400, 0));
+  std::vector<int> missing_indices;
+  std::vector<int> current_missing_index{0};
+  std::vector<int> total_missing_indices{0};
+  auto empty_row_indicator =
+      tvm::te::compute(Array<PrimExpr>{dense_shape[0]}, [&](const Array<Var>& indices) {
+        // for (int i = 0; i < GetConstInt(sparse_indices->shape[0]); ++i) {
+        //   sparse_indices[i]
+        // }
+        PrimExpr current_number = sparse_indices[indices[0] - total_missing_indices[0]];
+
+        bool cur_flag = true;
+        for (; cur_flag;) {
+          PrimExpr ret = if_then_else(current_number <= current_missing_index[0], 1, -1);
+          if (ret.as<IntImmNode>()->value == 1) {
+            PrimExpr ret2 = if_then_else(current_number == current_missing_index[0], 1, -1);
+            if (ret2.as<IntImmNode>()->value == 1) {
+              current_missing_index[0]++;
+              return PrimExpr(Bool(1));
+            } else {
+              current_number += 1;
+            }
+          } else {
+            total_missing_indices[0]++;
+          }
+        }
+        return PrimExpr(Bool(1));
+      });
+  result.push_back(compute(sp_ordered_output_shape,
+                           [&](const Array<Var>& indices) {
+                             PrimExpr ret = -1;
+                             //  ret += missing_index;
+                             //  int missing_index = 0;
+                             // PrimExpr current_missing_index = 0;
+                             // PrimExpr count_missing_indices = 0;
+                             // for (int i = 0; i < GetConstInt(sparse_indices->shape[0]); ++i)
+                             // {
+                             //   PrimExpr is_missing_index = if_then_else(sparse_indices[i][0]
+                             //   <= current_missing_index,
+                             //                                            current_missing_index,
+                             //                                            -1);
+                             //   if (const IntImmNode* op = is_missing_index.as<IntImmNode>())
+                             //   {
+                             //     if (op->value == -1) {
+                             //       PrimExpr on_current_indices =
+                             //           if_then_else(indices[0] == i + count_missing_indices,
+                             //           current_missing_index, -1);
+                             //       if (const IntImmNode* op =
+                             //       is_missing_index.as<IntImmNode>())
+                             //       {
+                             //         if (op->value == -1) {
+                             //           continue;
+                             //         } else {
+                             //           for (int j = 0; j < 6; ++j) {
+                             //             break;
+                             //           }
+                             //         }
+                             //       }
+                             //       count_missing_indices += 1;
+                             //     } else {
+                             //       PrimExpr current_missing_index =
+                             //           if_then_else(sparse_indices[i][0] ==
+                             //           current_missing_index,
+                             //                        current_missing_index + 1,
+                             //                        current_missing_index);
+                             //     }
+                             //   }
+                             // }
+                             return ret;
+                           },
+                           name, tag));
+  result.push_back(compute(Array<PrimExpr>{dense_shape[0]},
+                           [&](const Array<Var>& i) {
+                             PrimExpr ret = Bool(1);
+                             return ret;
+                           },
+                           name, tag));
+  return result;
+}
+
+inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& sparse_values,
+                                   const Tensor& prev_shape, const Tensor& new_shape,
+                                   const std::string name = "T_sparsereshape",
+                                   std::string tag = kInjective) {
+  Array<Tensor> result;
+  Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0], new_shape->shape[0]};
+  std::vector<PrimExpr> multipliers(GetConstInt(prev_shape->shape[0]), 1);
+  std::vector<PrimExpr> dividers(GetConstInt(new_shape->shape[0]), 1);
+
+  tvm::te::compute(Array<PrimExpr>{1}, [&](const Array<Var>& indices) {
+    tvm::PrimExpr total_ele = prev_shape[0];
+    for (int i = GetConstInt(prev_shape->shape[0]) - 2; i >= 0; --i) {
+      multipliers[i] = prev_shape[i + 1] * multipliers[i + 1];
+      total_ele *= prev_shape[i + 1];
+    }
+    PrimExpr division_total_ele = 1;
+    for (int i = 0; i < GetConstInt(new_shape->shape[0]); ++i) {
+      division_total_ele *= if_then_else(new_shape[i] != -1, new_shape[i], 1);
+    }
+    for (int i = GetConstInt(new_shape->shape[0]) - 2; i >= 0; --i) {
+      dividers[i] = dividers[i + 1] * if_then_else(new_shape[i + 1] != -1, new_shape[i + 1],
+                                                   div(total_ele, division_total_ele));
+    }
+    return PrimExpr(1);
+  });
+
+  result.push_back(compute(new_sparse_indices_shape,
+                           [&](const Array<Var>& indices) {
+                             PrimExpr flattened_idx = 0;
+                             if (sparse_indices->shape.size() == 1) {
+                               flattened_idx += sparse_indices[indices[0]];
+                             } else {
+                               for (int k = 0; k < GetConstInt(sparse_indices->shape[1]); k++) {
+                                 flattened_idx += (sparse_indices[indices[0]][k] * multipliers[k]);
+                               }
+                             }
+                             Array<PrimExpr> new_sparse_indices;
+                             if (GetConstInt(new_shape->shape[0]) != 1) {
+                               for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
+                                 new_sparse_indices.push_back(floordiv(flattened_idx, dividers[i]));
+                                 flattened_idx = floormod(flattened_idx, dividers[i]);
+                               }
+                               PrimExpr ret = -1;
+
+                               for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
+                                 //  auto ret = tir::Select(indices[1] == i, new_sparse_indices[i],
+                                 //  -1);
+                                 if (indices.size() == 1) {
+                                   return new_sparse_indices[0];
+                                 } else {
+                                   ret = if_then_else(indices[1] == i, new_sparse_indices[i], ret);
+                                   //  PrimExpr cond = (ret == -1);
+                                   if (const IntImmNode* op = ret.as<IntImmNode>()) {
+                                     if (op->value == -1) {
+                                       continue;
+                                     } else {
+                                       break;
+                                     }
+                                   }
+                                 }
+                               }
+                               return ret;
+                             } else {
+                               return flattened_idx;
+                             }
+                           },
+                           name, tag));
+  result.push_back(compute(sparse_values->shape,
+                           [&](const Array<Var>& i) { return (sparse_values(i)); }, name, tag));
+  return result;
+}  // namespace topi
 /*!
  * \brief Transform the layout according to \p src_layout and \p dst_layout
  * \param src the source input.

From 2e017fd1c811a8dde847b5c3b554de3faa7f3b82 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Thu, 17 Dec 2020 22:50:33 +0000
Subject: [PATCH 16/36] Correct Clang format version

---
 include/tvm/topi/transform.h | 189 ++++++++++++++++++-----------------
 1 file changed, 96 insertions(+), 93 deletions(-)

diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index 3f2c22cf024..b9900cff704 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -506,7 +506,7 @@ inline Array<Tensor> split(const Tensor& x, Array<PrimExpr> split_indices, int a
     begin_ids.push_back(idx);
   }
 
-  Array<Array<PrimExpr> > out_shapes;
+  Array<Array<PrimExpr>> out_shapes;
   for (size_t i = 0; i < begin_ids.size(); ++i) {
     PrimExpr out_axis_size;
     if (i == begin_ids.size() - 1) {
@@ -1430,55 +1430,57 @@ inline Array<Tensor> SparseFillEmptyRows(const Tensor& sparse_indices, const Ten
         }
         return PrimExpr(Bool(1));
       });
-  result.push_back(compute(sp_ordered_output_shape,
-                           [&](const Array<Var>& indices) {
-                             PrimExpr ret = -1;
-                             //  ret += missing_index;
-                             //  int missing_index = 0;
-                             // PrimExpr current_missing_index = 0;
-                             // PrimExpr count_missing_indices = 0;
-                             // for (int i = 0; i < GetConstInt(sparse_indices->shape[0]); ++i)
-                             // {
-                             //   PrimExpr is_missing_index = if_then_else(sparse_indices[i][0]
-                             //   <= current_missing_index,
-                             //                                            current_missing_index,
-                             //                                            -1);
-                             //   if (const IntImmNode* op = is_missing_index.as<IntImmNode>())
-                             //   {
-                             //     if (op->value == -1) {
-                             //       PrimExpr on_current_indices =
-                             //           if_then_else(indices[0] == i + count_missing_indices,
-                             //           current_missing_index, -1);
-                             //       if (const IntImmNode* op =
-                             //       is_missing_index.as<IntImmNode>())
-                             //       {
-                             //         if (op->value == -1) {
-                             //           continue;
-                             //         } else {
-                             //           for (int j = 0; j < 6; ++j) {
-                             //             break;
-                             //           }
-                             //         }
-                             //       }
-                             //       count_missing_indices += 1;
-                             //     } else {
-                             //       PrimExpr current_missing_index =
-                             //           if_then_else(sparse_indices[i][0] ==
-                             //           current_missing_index,
-                             //                        current_missing_index + 1,
-                             //                        current_missing_index);
-                             //     }
-                             //   }
-                             // }
-                             return ret;
-                           },
-                           name, tag));
-  result.push_back(compute(Array<PrimExpr>{dense_shape[0]},
-                           [&](const Array<Var>& i) {
-                             PrimExpr ret = Bool(1);
-                             return ret;
-                           },
-                           name, tag));
+  result.push_back(compute(
+      sp_ordered_output_shape,
+      [&](const Array<Var>& indices) {
+        PrimExpr ret = -1;
+        //  ret += missing_index;
+        //  int missing_index = 0;
+        // PrimExpr current_missing_index = 0;
+        // PrimExpr count_missing_indices = 0;
+        // for (int i = 0; i < GetConstInt(sparse_indices->shape[0]); ++i)
+        // {
+        //   PrimExpr is_missing_index = if_then_else(sparse_indices[i][0]
+        //   <= current_missing_index,
+        //                                            current_missing_index,
+        //                                            -1);
+        //   if (const IntImmNode* op = is_missing_index.as<IntImmNode>())
+        //   {
+        //     if (op->value == -1) {
+        //       PrimExpr on_current_indices =
+        //           if_then_else(indices[0] == i + count_missing_indices,
+        //           current_missing_index, -1);
+        //       if (const IntImmNode* op =
+        //       is_missing_index.as<IntImmNode>())
+        //       {
+        //         if (op->value == -1) {
+        //           continue;
+        //         } else {
+        //           for (int j = 0; j < 6; ++j) {
+        //             break;
+        //           }
+        //         }
+        //       }
+        //       count_missing_indices += 1;
+        //     } else {
+        //       PrimExpr current_missing_index =
+        //           if_then_else(sparse_indices[i][0] ==
+        //           current_missing_index,
+        //                        current_missing_index + 1,
+        //                        current_missing_index);
+        //     }
+        //   }
+        // }
+        return ret;
+      },
+      name, tag));
+  result.push_back(compute(
+      Array<PrimExpr>{dense_shape[0]},
+      [&](const Array<Var>& i) {
+        PrimExpr ret = Bool(1);
+        return ret;
+      },
+      name, tag));
   return result;
 }
 
@@ -1508,49 +1510,50 @@ inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& s
     return PrimExpr(1);
   });
 
-  result.push_back(compute(new_sparse_indices_shape,
-                           [&](const Array<Var>& indices) {
-                             PrimExpr flattened_idx = 0;
-                             if (sparse_indices->shape.size() == 1) {
-                               flattened_idx += sparse_indices[indices[0]];
-                             } else {
-                               for (int k = 0; k < GetConstInt(sparse_indices->shape[1]); k++) {
-                                 flattened_idx += (sparse_indices[indices[0]][k] * multipliers[k]);
-                               }
-                             }
-                             Array<PrimExpr> new_sparse_indices;
-                             if (GetConstInt(new_shape->shape[0]) != 1) {
-                               for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
-                                 new_sparse_indices.push_back(floordiv(flattened_idx, dividers[i]));
-                                 flattened_idx = floormod(flattened_idx, dividers[i]);
-                               }
-                               PrimExpr ret = -1;
-
-                               for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
-                                 //  auto ret = tir::Select(indices[1] == i, new_sparse_indices[i],
-                                 //  -1);
-                                 if (indices.size() == 1) {
-                                   return new_sparse_indices[0];
-                                 } else {
-                                   ret = if_then_else(indices[1] == i, new_sparse_indices[i], ret);
-                                   //  PrimExpr cond = (ret == -1);
-                                   if (const IntImmNode* op = ret.as<IntImmNode>()) {
-                                     if (op->value == -1) {
-                                       continue;
-                                     } else {
-                                       break;
-                                     }
-                                   }
-                                 }
-                               }
-                               return ret;
-                             } else {
-                               return flattened_idx;
-                             }
-                           },
-                           name, tag));
-  result.push_back(compute(sparse_values->shape,
-                           [&](const Array<Var>& i) { return (sparse_values(i)); }, name, tag));
+  result.push_back(compute(
+      new_sparse_indices_shape,
+      [&](const Array<Var>& indices) {
+        PrimExpr flattened_idx = 0;
+        if (sparse_indices->shape.size() == 1) {
+          flattened_idx += sparse_indices[indices[0]];
+        } else {
+          for (int k = 0; k < GetConstInt(sparse_indices->shape[1]); k++) {
+            flattened_idx += (sparse_indices[indices[0]][k] * multipliers[k]);
+          }
+        }
+        Array<PrimExpr> new_sparse_indices;
+        if (GetConstInt(new_shape->shape[0]) != 1) {
+          for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
+            new_sparse_indices.push_back(floordiv(flattened_idx, dividers[i]));
+            flattened_idx = floormod(flattened_idx, dividers[i]);
+          }
+          PrimExpr ret = -1;
+
+          for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
+            //  auto ret = tir::Select(indices[1] == i, new_sparse_indices[i],
+            //  -1);
+            if (indices.size() == 1) {
+              return new_sparse_indices[0];
+            } else {
+              ret = if_then_else(indices[1] == i, new_sparse_indices[i], ret);
+              //  PrimExpr cond = (ret == -1);
+              if (const IntImmNode* op = ret.as<IntImmNode>()) {
+                if (op->value == -1) {
+                  continue;
+                } else {
+                  break;
+                }
+              }
+            }
+          }
+          return ret;
+        } else {
+          return flattened_idx;
+        }
+      },
+      name, tag));
+  result.push_back(compute(
+      sparse_values->shape, [&](const Array<Var>& i) { return (sparse_values(i)); }, name, tag));
   return result;
 }  // namespace topi
 /*!

From b7000acb9adf727218377805de7d7191f425d9f5 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Thu, 17 Dec 2020 22:53:13 +0000
Subject: [PATCH 17/36] Reset_to_clang-format-10

---
 src/relay/op/tensor/transform.cc | 31 ++++++++++++++++---------------
 1 file changed, 16 insertions(+), 15 deletions(-)

diff --git a/src/relay/op/tensor/transform.cc b/src/relay/op/tensor/transform.cc
index 4348a60bb5c..e87b7fb150a 100644
--- a/src/relay/op/tensor/transform.cc
+++ b/src/relay/op/tensor/transform.cc
@@ -1339,11 +1339,12 @@ inline te::Tensor DynamicArange(const te::Tensor& start, const te::Tensor& stop,
                                 std::string name = "T_arange_dynamic",
                                 std::string tag = topi::kInjective) {
   tvm::PrimExpr num_elem = tvm::tir::Var("num_elem");
-  return te::compute({num_elem},
-                     [&](const Array<tvm::tir::Var>& indices) {
-                       return tvm::cast(dtype, start[0] + step[0] * indices[0]);
-                     },
-                     name, tag);
+  return te::compute(
+      {num_elem},
+      [&](const Array<tvm::tir::Var>& indices) {
+        return tvm::cast(dtype, start[0] + step[0] * indices[0]);
+      },
+      name, tag);
 }
 
 Array<te::Tensor> ArangeCompute(const Attrs& attrs, const Array<te::Tensor>& inputs,
@@ -2500,16 +2501,16 @@ Array<te::Tensor> StridedSliceCompute(const Attrs& attrs, const Array<te::Tensor
           tir::make_const((strides.size() != 0 ? strides[0].dtype() : begin[0].dtype()),
                           (i < strides.size() ? strides[i]->value : 1)));
     }
-    return Array<te::Tensor>{
-        te::compute(out_shape,
-                    [&](const Array<tir::Var>& indices) {
-                      Array<PrimExpr> real_indices;
-                      for (size_t i = 0; i < src_tensor_dim; ++i) {
-                        real_indices.push_back(indices[i] * strides_expr[i] + begin_expr[i]);
-                      }
-                      return input(real_indices);
-                    },
-                    std::string{"T_strided_slice_dynamic"}, std::string{topi::kInjective})};
+    return Array<te::Tensor>{te::compute(
+        out_shape,
+        [&](const Array<tir::Var>& indices) {
+          Array<PrimExpr> real_indices;
+          for (size_t i = 0; i < src_tensor_dim; ++i) {
+            real_indices.push_back(indices[i] * strides_expr[i] + begin_expr[i]);
+          }
+          return input(real_indices);
+        },
+        std::string{"T_strided_slice_dynamic"}, std::string{topi::kInjective})};
   } else {
     for (size_t i = 0; i < begin.size(); ++i) {
       begin_expr.push_back(begin[i]);

From f14672ab2d3f6255e9a183b2485460a1a031186e Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Thu, 17 Dec 2020 23:46:37 +0000
Subject: [PATCH 19/36] Remove SparseFill Changes

---
 include/tvm/relay/attrs/transform.h  |   7 --
 include/tvm/topi/transform.h         | 102 ---------------------------
 python/tvm/relay/op/transform.py     |  18 +++--
 python/tvm/topi/transform.py         |  19 -----
 src/relay/op/tensor/transform.cc     |  55 ---------------
 tests/python/relay/test_op_level3.py |  50 -------------
 6 files changed, 13 insertions(+), 238 deletions(-)

diff --git a/include/tvm/relay/attrs/transform.h b/include/tvm/relay/attrs/transform.h
index db905faa03f..cbe989f9355 100644
--- a/include/tvm/relay/attrs/transform.h
+++ b/include/tvm/relay/attrs/transform.h
@@ -401,13 +401,6 @@ struct SparseToDenseAttrs : public tvm::AttrsNode<SparseToDenseAttrs> {
   }
 };  // struct SparseToDenseAttrs
 
-struct SparseFillEmptyRowsAttrs : public tvm::AttrsNode<SparseFillEmptyRowsAttrs> {
-  Array<Integer> dense_shape;
-
-  TVM_DECLARE_ATTRS(SparseFillEmptyRowsAttrs, "relay.attrs.SparseFillEmptyRowsAttrs") {
-    TVM_ATTR_FIELD(dense_shape).describe("Shape of the dense output tensor");
-  }
-};  // struct SparseFillEmptyRowsAttrs
 /*! \brief Attributes for ndarray_size operator */
 struct NdarraySizeAttrs : public tvm::AttrsNode<NdarraySizeAttrs> {
   DataType dtype;
diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index b9900cff704..7385c13f593 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -1386,104 +1386,6 @@ inline Array<Tensor> meshgrid(const Array<Tensor>& inputs, const std::string& in
   return result;
 }
 
-inline Array<Tensor> SparseFillEmptyRows(const Tensor& sparse_indices, const Tensor& sparse_values,
-                                         const Tensor& default_value,
-                                         const Array<Integer>& dense_shape,
-                                         const std::string name = "T_sparsefillemptyrows",
-                                         std::string tag = kInjective) {
-  Array<Tensor> result;
-  Array<PrimExpr> sp_ordered_output_shape;
-  sp_ordered_output_shape.push_back(dense_shape[0] + sparse_indices->shape[0]);
-  if (sparse_indices->shape.size() > 1) {
-    sp_ordered_output_shape.push_back(sparse_indices->shape[1]);
-  }
-  int num_rows = static_cast<int>(dense_shape[0]) + GetConstInt(sparse_indices->shape[0]);
-  int num_cols = GetConstInt(sparse_indices->shape[1]);
-  std::vector<std::vector<PrimExpr>> sp_ordered_output(
-      num_rows, std::vector<PrimExpr>(num_cols, PrimExpr(-1)));
-
-  // std::vector<std::vector<int>> vec(100, std::vector<int>(400, 0));
-  std::vector<int> missing_indices;
-  std::vector<int> current_missing_index{0};
-  std::vector<int> total_missing_indices{0};
-  auto empty_row_indicator =
-      tvm::te::compute(Array<PrimExpr>{dense_shape[0]}, [&](const Array<Var>& indices) {
-        // for (int i = 0; i < GetConstInt(sparse_indices->shape[0]); ++i) {
-        //   sparse_indices[i]
-        // }
-        PrimExpr current_number = sparse_indices[indices[0] - total_missing_indices[0]];
-
-        bool cur_flag = true;
-        for (; cur_flag;) {
-          PrimExpr ret = if_then_else(current_number <= current_missing_index[0], 1, -1);
-          if (ret.as<IntImmNode>()->value == 1) {
-            PrimExpr ret2 = if_then_else(current_number == current_missing_index[0], 1, -1);
-            if (ret2.as<IntImmNode>()->value == 1) {
-              current_missing_index[0]++;
-              return PrimExpr(Bool(1));
-            } else {
-              current_number += 1;
-            }
-          } else {
-            total_missing_indices[0]++;
-          }
-        }
-        return PrimExpr(Bool(1));
-      });
-  result.push_back(compute(
-      sp_ordered_output_shape,
-      [&](const Array<Var>& indices) {
-        PrimExpr ret = -1;
-        //  ret += missing_index;
-        //  int missing_index = 0;
-        // PrimExpr current_missing_index = 0;
-        // PrimExpr count_missing_indices = 0;
-        // for (int i = 0; i < GetConstInt(sparse_indices->shape[0]); ++i)
-        // {
-        //   PrimExpr is_missing_index = if_then_else(sparse_indices[i][0]
-        //   <= current_missing_index,
-        //                                            current_missing_index,
-        //                                            -1);
-        //   if (const IntImmNode* op = is_missing_index.as<IntImmNode>())
-        //   {
-        //     if (op->value == -1) {
-        //       PrimExpr on_current_indices =
-        //           if_then_else(indices[0] == i + count_missing_indices,
-        //           current_missing_index, -1);
-        //       if (const IntImmNode* op =
-        //       is_missing_index.as<IntImmNode>())
-        //       {
-        //         if (op->value == -1) {
-        //           continue;
-        //         } else {
-        //           for (int j = 0; j < 6; ++j) {
-        //             break;
-        //           }
-        //         }
-        //       }
-        //       count_missing_indices += 1;
-        //     } else {
-        //       PrimExpr current_missing_index =
-        //           if_then_else(sparse_indices[i][0] ==
-        //           current_missing_index,
-        //                        current_missing_index + 1,
-        //                        current_missing_index);
-        //     }
-        //   }
-        // }
-        return ret;
-      },
-      name, tag));
-  result.push_back(compute(
-      Array<PrimExpr>{dense_shape[0]},
-      [&](const Array<Var>& i) {
-        PrimExpr ret = Bool(1);
-        return ret;
-      },
-      name, tag));
-  return result;
-}
-
 inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& sparse_values,
                                    const Tensor& prev_shape, const Tensor& new_shape,
                                    const std::string name = "T_sparsereshape",
@@ -1509,7 +1411,6 @@ inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& s
     }
     return PrimExpr(1);
   });
-
   result.push_back(compute(
       new_sparse_indices_shape,
       [&](const Array<Var>& indices) {
@@ -1530,13 +1431,10 @@ inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& s
           PrimExpr ret = -1;
 
           for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
-            //  auto ret = tir::Select(indices[1] == i, new_sparse_indices[i],
-            //  -1);
             if (indices.size() == 1) {
               return new_sparse_indices[0];
             } else {
               ret = if_then_else(indices[1] == i, new_sparse_indices[i], ret);
-              //  PrimExpr cond = (ret == -1);
               if (const IntImmNode* op = ret.as<IntImmNode>()) {
                 if (op->value == -1) {
                   continue;
diff --git a/python/tvm/relay/op/transform.py b/python/tvm/relay/op/transform.py
index 5b4573e1d82..f315acc6553 100644
--- a/python/tvm/relay/op/transform.py
+++ b/python/tvm/relay/op/transform.py
@@ -1322,11 +1322,19 @@ def adv_index(inputs):
     return _make.adv_index(Tuple(inputs))
 
 
-def sparsefillemptyrows(sparse_indices, sparse_values, dense_shape, default_value):
-
-    return _make.sparsefillemptyrows(sparse_indices, sparse_values, dense_shape, default_value)
-
-
 def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
+    """
+    Reshape a Sparse Tensor
+
+    Parameters
+    ----------
+    inputs : List[relay.Expr]
+        Input tensor and indices.
+        The first tensor is input data and rests are indices.
 
+    Returns
+    -------
+    result: relay.Expr
+        Output tensor.
+    """
     return _make.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)
\ No newline at end of file
diff --git a/python/tvm/topi/transform.py b/python/tvm/topi/transform.py
index 1ff5a8096ba..2f4a4683d8d 100644
--- a/python/tvm/topi/transform.py
+++ b/python/tvm/topi/transform.py
@@ -933,25 +933,6 @@ def adv_index(data, indices):
     return cpp.adv_index(data, indices)
 
 
-def sparsefillemptyrows(sparse_indices, sparse_values, default_value, dense_shape):
-    """Numpy style indexing with tensors.
-
-    Parameters
-    ----------
-    data : tvm.te.Tensor
-        Input data.
-
-    indices : A list of tvm.te.Tensor
-        Tensor index.
-
-    Returns
-    -------
-    result : tvm.te.Tensor
-        Output tensor
-    """
-    return cpp.sparsefillemptyrows(sparse_indices, sparse_values, default_value, dense_shape)
-
-
 def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
     """Numpy style indexing with tensors.
 
diff --git a/src/relay/op/tensor/transform.cc b/src/relay/op/tensor/transform.cc
index e87b7fb150a..fda4b1d328d 100644
--- a/src/relay/op/tensor/transform.cc
+++ b/src/relay/op/tensor/transform.cc
@@ -1596,61 +1596,6 @@ RELAY_REGISTER_OP("sparsereshape")
     .set_support_level(3)
     .set_attr<FTVMCompute>("FTVMCompute", SparseReshapeCompute);
 
-TVM_REGISTER_NODE_TYPE(SparseFillEmptyRowsAttrs);
-
-bool SparseFillEmptyRowsRel(const Array<Type>& types, int num_inputs, const Attrs& attrs,
-                            const TypeReporter& reporter) {
-  // types: [ sparse_indices, sparse_values, default_value, result]
-  ICHECK_EQ(types.size(), 4);
-  ICHECK_EQ(num_inputs, 3);
-  std::vector<Type> fields;
-  auto sparse_indices = types[0].as<TensorTypeNode>();
-
-  const auto* param = attrs.as<SparseFillEmptyRowsAttrs>();
-  CHECK(param != nullptr);
-
-  Array<IndexExpr> sp_ordered_output_shape;
-  sp_ordered_output_shape.push_back(param->dense_shape[0] + sparse_indices->shape[0]);
-  if (sparse_indices->shape.size() > 1) {
-    sp_ordered_output_shape.push_back(sparse_indices->shape[1]);
-  }
-  fields.push_back(TensorType(sp_ordered_output_shape, sparse_indices->dtype));
-  fields.push_back(TensorType(Array<PrimExpr>{param->dense_shape[0]}, tvm::DataType::Bool()));
-  reporter->Assign(types[3], TupleType(Array<Type>(fields)));
-  return true;
-}
-
-Array<te::Tensor> SparseFillEmptyRowsCompute(const Attrs& attrs, const Array<te::Tensor>& inputs,
-                                             const Type& out_type) {
-  CHECK_EQ(inputs.size(), 3);
-  const auto* param = attrs.as<SparseFillEmptyRowsAttrs>();
-  CHECK(param != nullptr);
-  return {topi::SparseFillEmptyRows(inputs[0], inputs[1], inputs[2], param->dense_shape)};
-}
-
-Expr MakeSparseFillEmptyRows(Expr sparse_indices, Expr sparse_values, Expr default_value,
-                             Array<Integer> dense_shape) {
-  auto attrs = make_object<SparseFillEmptyRowsAttrs>();
-  attrs->dense_shape = std::move(dense_shape);
-  static const Op& op = Op::Get("sparsefillemptyrows");
-  return Call(op, {sparse_indices, sparse_values, default_value}, Attrs(attrs), {});
-}
-
-TVM_REGISTER_GLOBAL("relay.op._make.sparsefillemptyrows").set_body_typed(MakeSparseFillEmptyRows);
-
-RELAY_REGISTER_OP("sparsefillemptyrows")
-    .describe(R"code(Return twice of normal addition of two tensors.
-)code" TVM_ADD_FILELINE)
-    .set_num_inputs(3)
-    .set_attrs_type<SparseFillEmptyRowsAttrs>()
-    .add_argument("sparse_indices", "Tensor", "The first tensor")
-    .add_argument("sparse_values", "Tensor", "The second tensor")
-    .add_argument("default_value", "Tensor", "The third tensor")
-    .add_type_rel("sparsefillemptyrows", SparseFillEmptyRowsRel)
-    .set_support_level(3)
-    .set_attr<TOpPattern>("TOpPattern", kInjective)
-    .set_attr<FTVMCompute>("FTVMCompute", SparseFillEmptyRowsCompute);
-
 // tile operator
 TVM_REGISTER_NODE_TYPE(TileAttrs);
 
diff --git a/tests/python/relay/test_op_level3.py b/tests/python/relay/test_op_level3.py
index de4265a5a5b..b6998f34d19 100644
--- a/tests/python/relay/test_op_level3.py
+++ b/tests/python/relay/test_op_level3.py
@@ -1042,55 +1042,6 @@ def verify_scatter_add(dshape, ishape, axis=0, dtype="float32"):
     verify_scatter_add((16, 16, 4, 5), (16, 16, 4, 5), 3)
 
 
-@tvm.testing.uses_gpu
-def test_sparsefillemptyrows():
-    def ref_sparsefillemptyrows(sparse_indices, sparse_values, default_value, dense_shape):
-        new_sparse_indices = -1 * np.ones(
-            (sparse_indices.shape[0] + dense_shape[0], sparse_indices.shape[1])
-        )
-        empty_row_indicator = np.ones(dense_shape[0], dtype=bool)
-
-        return new_sparse_indices, empty_row_indicator
-
-    def verify_sparsefillemptyrows(
-        sparse_indices_np, sparse_values_np, default_value_np, dense_shape_np
-    ):
-        sparse_indices = relay.var(
-            "sparse_indices",
-            relay.TensorType(sparse_indices_np.shape, str(sparse_indices_np.dtype)),
-        )
-        sparse_values = relay.var(
-            "sparse_values", relay.TensorType(sparse_values_np.shape, str(sparse_values_np.dtype))
-        )
-        default_value = relay.var(
-            "default_value", relay.TensorType(default_value_np.shape, str(default_value_np.dtype))
-        )
-        z = relay.op.sparsefillemptyrows(
-            sparse_indices, sparse_values, default_value, list(dense_shape_np)
-        )
-
-        func = relay.Function([sparse_indices, sparse_values, default_value], z)
-
-        ref_res = ref_sparsefillemptyrows(
-            sparse_indices_np, sparse_values_np, default_value_np, dense_shape_np
-        )
-        for target, ctx in tvm.testing.enabled_targets():
-            for kind in ["graph", "debug"]:
-                intrp = relay.create_executor(kind, ctx=ctx, target=target)
-                op_res = intrp.evaluate(func)(sparse_indices_np, sparse_values_np, default_value_np)
-                for op_res_item, ref_res_item in zip(op_res, ref_res):
-                    print(op_res_item, ref_res_item)
-                    tvm.testing.assert_allclose(op_res_item.asnumpy(), ref_res_item, rtol=1e-5)
-
-    sparse_indices_np = np.array([[0, 1], [0, 3], [2, 0], [3, 1]], dtype=np.int32)
-    sparse_values_np = np.array([1, 2, 3, 4], dtype=np.int32)
-    dense_shape_np = np.array([5, 6], dtype=np.int32)
-    default_value_np = np.array([10], dtype=np.int32)
-    verify_sparsefillemptyrows(
-        sparse_indices_np, sparse_values_np, default_value_np, dense_shape_np
-    )
-
-
 @tvm.testing.uses_gpu
 def test_sparsereshape():
     def ref_sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
@@ -1471,7 +1422,6 @@ def verify_adv_index(data_shape, index_shapes):
 
 
 if __name__ == "__main__":
-    test_sparsefillemptyrows()
     test_sparsereshape()
     test_cast()
     test_zeros_ones()

From 069015549e99411cb7d2d1dc14b1f7a8567010f3 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Fri, 18 Dec 2020 00:14:07 +0000
Subject: [PATCH 20/36] PR stuff

---
 include/tvm/topi/transform.h         |  2 --
 python/tvm/relay/op/transform.py     | 26 ++++++++++++++++++
 python/tvm/topi/transform.py         | 41 ++++++++++++++++++++++------
 src/relay/op/tensor/transform.cc     |  8 +-----
 tests/python/relay/test_op_level3.py | 30 ++++++++++++++------
 5 files changed, 81 insertions(+), 26 deletions(-)

diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index 7385c13f593..88d7bc94330 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -1450,8 +1450,6 @@ inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& s
         }
       },
       name, tag));
-  result.push_back(compute(
-      sparse_values->shape, [&](const Array<Var>& i) { return (sparse_values(i)); }, name, tag));
   return result;
 }  // namespace topi
 /*!
diff --git a/python/tvm/relay/op/transform.py b/python/tvm/relay/op/transform.py
index f315acc6553..9e5df9de30c 100644
--- a/python/tvm/relay/op/transform.py
+++ b/python/tvm/relay/op/transform.py
@@ -1336,5 +1336,31 @@ def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
     -------
     result: relay.Expr
         Output tensor.
+    Examples
+        --------
+        .. code-block:: python
+
+            sparse_indices = [[0, 0, 0],
+                              [0, 0, 1],
+                              [0, 1, 0],
+                              [1, 0, 0],
+                              [1, 2, 3]]
+
+            sparse_values = [7, 5, 6, 3, 9]
+
+            prev_shape = [2, 3, 4]
+
+            new_shape = [9, -1]
+
+            relay.sparsereshape(sparse_indices,
+                                sparse_values,
+                                prev_shape,
+                                new_shape)
+             =   [[0, 0],
+                  [0, 1],
+                  [1, 2],
+                  [4, 2],
+                  [8, 1]]
+
     """
     return _make.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)
\ No newline at end of file
diff --git a/python/tvm/topi/transform.py b/python/tvm/topi/transform.py
index 2f4a4683d8d..87016cf99c3 100644
--- a/python/tvm/topi/transform.py
+++ b/python/tvm/topi/transform.py
@@ -934,19 +934,44 @@ def adv_index(data, indices):
 
 
 def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
-    """Numpy style indexing with tensors.
+    """
+    Reshape a Sparse Tensor
 
     Parameters
     ----------
-    data : tvm.te.Tensor
-        Input data.
-
-    indices : A list of tvm.te.Tensor
-        Tensor index.
+    inputs : List[relay.Expr]
+        Input tensor and indices.
+        The first tensor is input data and rests are indices.
 
     Returns
     -------
-    result : tvm.te.Tensor
-        Output tensor
+    result: relay.Expr
+        Output tensor.
+    Examples
+        --------
+        .. code-block:: python
+
+            sparse_indices = [[0, 0, 0],
+                              [0, 0, 1],
+                              [0, 1, 0],
+                              [1, 0, 0],
+                              [1, 2, 3]]
+
+            sparse_values = [7, 5, 6, 3, 9]
+
+            prev_shape = [2, 3, 4]
+
+            new_shape = [9, -1]
+
+            relay.sparsereshape(sparse_indices,
+                                sparse_values,
+                                prev_shape,
+                                new_shape)
+             =   [[0, 0],
+                  [0, 1],
+                  [1, 2],
+                  [4, 2],
+                  [8, 1]]
+
     """
     return cpp.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)
\ No newline at end of file
diff --git a/src/relay/op/tensor/transform.cc b/src/relay/op/tensor/transform.cc
index fda4b1d328d..1089bd0835a 100644
--- a/src/relay/op/tensor/transform.cc
+++ b/src/relay/op/tensor/transform.cc
@@ -1557,17 +1557,11 @@ bool SparseReshapeRel(const Array<Type>& types, int num_inputs, const Attrs& raw
                       const TypeReporter& reporter) {
   // types: [sparse_indices, sparse_values, prev_shape, new_shape, result]
   ICHECK_EQ(types.size(), 5);
-
-  std::vector<Type> fields;
   auto sparse_indices = types[0].as<TensorTypeNode>();
-  auto sparse_values = types[1].as<TensorTypeNode>();
   auto new_shape = types[3].as<TensorTypeNode>();
 
   Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0], new_shape->shape[0]};
-  fields.push_back(TensorType(new_sparse_indices_shape, sparse_indices->dtype));
-  fields.push_back(TensorType(sparse_values->shape, sparse_values->dtype));
-
-  reporter->Assign(types[4], TupleType(Array<Type>(fields)));
+  reporter->Assign(types[4], TensorType(new_sparse_indices_shape, sparse_indices->dtype));
   return true;
 }
 
diff --git a/tests/python/relay/test_op_level3.py b/tests/python/relay/test_op_level3.py
index b6998f34d19..6ca08e6c8d0 100644
--- a/tests/python/relay/test_op_level3.py
+++ b/tests/python/relay/test_op_level3.py
@@ -1044,8 +1044,15 @@ def verify_scatter_add(dshape, ishape, axis=0, dtype="float32"):
 
 @tvm.testing.uses_gpu
 def test_sparsereshape():
-    def ref_sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
-        # sparse_indices[0][0] = 1
+    def ref_sparsereshape(
+        sparse_indices: np.ndarray,
+        sparse_values: np.ndarray,
+        prev_shape: np.ndarray,
+        new_shape: np.ndarray,
+    ):
+    """
+    This function calculates the expected output of sparseshape operator given the inputs. 
+    """
         new_sparse_indices = np.ones(
             (sparse_values.shape[0], new_shape.shape[0]), dtype=sparse_indices.dtype
         )
@@ -1078,12 +1085,18 @@ def ref_sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
             else:
                 new_sparse_indices[row_num] = flat_idx
 
-        return (
-            new_sparse_indices,
-            sparse_values,
-        )
-
-    def verify_sparsereshape(sparse_indices_np, sparse_values_np, dense_shape_np, default_value_np):
+        return new_sparse_indices
+            
+
+    def verify_sparsereshape(
+        sparse_indices_np: np.ndarray,
+        sparse_values_np: np.ndarray,
+        dense_shape_np: np.ndarray,
+        default_value_np: np.ndarray,
+    ):
+    """
+    This function verifies the relay output of sparsereshape with its expected output. 
+    """
         sparse_indices = relay.var(
             "sparse_indices",
             relay.TensorType(sparse_indices_np.shape, str(sparse_indices_np.dtype)),
@@ -1111,7 +1124,6 @@ def verify_sparsereshape(sparse_indices_np, sparse_values_np, dense_shape_np, de
                     sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np
                 )
                 for op_res_item, ref_res_item in zip(op_res, ref_res):
-                    print(f"Op Res: {op_res_item}, Ref Res: {ref_res_item}")
                     tvm.testing.assert_allclose(
                         op_res_item.asnumpy(), ref_res_item, rtol=1e-5, atol=1e-5
                     )

From 8c1f1f48cba2e61544c8ace41bfbee4259f48a54 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Fri, 18 Dec 2020 00:18:44 +0000
Subject: [PATCH 21/36] Done

---
 python/tvm/relay/op/_transform.py    |  1 -
 tests/python/relay/test_op_level3.py | 21 ++++++++++-----------
 2 files changed, 10 insertions(+), 12 deletions(-)

diff --git a/python/tvm/relay/op/_transform.py b/python/tvm/relay/op/_transform.py
index 4f31dbde152..cd1dd0e381a 100644
--- a/python/tvm/relay/op/_transform.py
+++ b/python/tvm/relay/op/_transform.py
@@ -63,7 +63,6 @@
 _reg.register_injective_schedule("sparse_to_dense")
 _reg.register_injective_schedule("matrix_set_diag")
 _reg.register_injective_schedule("adv_index")
-_reg.register_injective_schedule("sparsefillemptyrows")
 _reg.register_injective_schedule("sparsereshape")
 
 
diff --git a/tests/python/relay/test_op_level3.py b/tests/python/relay/test_op_level3.py
index 6ca08e6c8d0..64f693f085e 100644
--- a/tests/python/relay/test_op_level3.py
+++ b/tests/python/relay/test_op_level3.py
@@ -1050,9 +1050,9 @@ def ref_sparsereshape(
         prev_shape: np.ndarray,
         new_shape: np.ndarray,
     ):
-    """
-    This function calculates the expected output of sparseshape operator given the inputs. 
-    """
+        """
+        This function calculates the expected output of sparseshape operator given the inputs.
+        """
         new_sparse_indices = np.ones(
             (sparse_values.shape[0], new_shape.shape[0]), dtype=sparse_indices.dtype
         )
@@ -1086,7 +1086,6 @@ def ref_sparsereshape(
                 new_sparse_indices[row_num] = flat_idx
 
         return new_sparse_indices
-            
 
     def verify_sparsereshape(
         sparse_indices_np: np.ndarray,
@@ -1094,9 +1093,9 @@ def verify_sparsereshape(
         dense_shape_np: np.ndarray,
         default_value_np: np.ndarray,
     ):
-    """
-    This function verifies the relay output of sparsereshape with its expected output. 
-    """
+        """
+        This function verifies the relay output of sparsereshape with its expected output.
+        """
         sparse_indices = relay.var(
             "sparse_indices",
             relay.TensorType(sparse_indices_np.shape, str(sparse_indices_np.dtype)),
@@ -1123,10 +1122,7 @@ def verify_sparsereshape(
                 op_res = intrp.evaluate(func)(
                     sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np
                 )
-                for op_res_item, ref_res_item in zip(op_res, ref_res):
-                    tvm.testing.assert_allclose(
-                        op_res_item.asnumpy(), ref_res_item, rtol=1e-5, atol=1e-5
-                    )
+                tvm.testing.assert_allclose(op_res.asnumpy(), ref_res, rtol=1e-5, atol=1e-5)
 
     sparse_indices_np = np.array(
         [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]], dtype=np.int32
@@ -1435,6 +1431,9 @@ def verify_adv_index(data_shape, index_shapes):
 
 if __name__ == "__main__":
     test_sparsereshape()
+    import sys
+
+    sys.exit()
     test_cast()
     test_zeros_ones()
     test_unary_identity()

From 2730eff3685abb49f46796e9cc2320761f09bfe4 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Fri, 18 Dec 2020 00:19:36 +0000
Subject: [PATCH 22/36] Done

---
 tests/python/relay/test_op_level3.py | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/tests/python/relay/test_op_level3.py b/tests/python/relay/test_op_level3.py
index 64f693f085e..b87301eba44 100644
--- a/tests/python/relay/test_op_level3.py
+++ b/tests/python/relay/test_op_level3.py
@@ -1431,9 +1431,6 @@ def verify_adv_index(data_shape, index_shapes):
 
 if __name__ == "__main__":
     test_sparsereshape()
-    import sys
-
-    sys.exit()
     test_cast()
     test_zeros_ones()
     test_unary_identity()

From 58bae15401284511b7a4d40ed3de2c146b9c4cc9 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Fri, 18 Dec 2020 00:24:34 +0000
Subject: [PATCH 23/36] Add Brief;

---
 include/tvm/topi/transform.h | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index 88d7bc94330..a9d5c7a360d 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -1386,6 +1386,19 @@ inline Array<Tensor> meshgrid(const Array<Tensor>& inputs, const std::string& in
   return result;
 }
 
+/*!
+ * \brief Compute new sparse indices and return them after the sparsereshape operation
+ *
+ * \param sparse_indices Indices where values of the dense tensor exist
+ * \param sparse_values Values at the above indices respectively
+ * \param prev_shape Old Shape of the sparse tensor corresponding to sparse_indices
+ * \param new_shape Desired Shape of the sparse tensor which will correspond to output
+ * \param name The name of the operation
+ * \param tag The tag to mark the operation
+ *
+ * \return A Tensor whose op member is the sparsereshape operation
+ */
+
 inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& sparse_values,
                                    const Tensor& prev_shape, const Tensor& new_shape,
                                    const std::string name = "T_sparsereshape",

From b1cbce09791e11fd02978465c69a422550137423 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Fri, 18 Dec 2020 00:27:02 +0000
Subject: [PATCH 24/36] Black

---
 python/tvm/relay/op/transform.py | 2 +-
 python/tvm/topi/transform.py     | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/python/tvm/relay/op/transform.py b/python/tvm/relay/op/transform.py
index 9e5df9de30c..811863fe124 100644
--- a/python/tvm/relay/op/transform.py
+++ b/python/tvm/relay/op/transform.py
@@ -1363,4 +1363,4 @@ def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
                   [8, 1]]
 
     """
-    return _make.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)
\ No newline at end of file
+    return _make.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)
diff --git a/python/tvm/topi/transform.py b/python/tvm/topi/transform.py
index 87016cf99c3..717b99e2251 100644
--- a/python/tvm/topi/transform.py
+++ b/python/tvm/topi/transform.py
@@ -974,4 +974,4 @@ def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
                   [8, 1]]
 
     """
-    return cpp.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)
\ No newline at end of file
+    return cpp.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)

From bee77e00359e2385ac602f1f59eacc664ff41f12 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Mon, 21 Dec 2020 11:23:27 +0000
Subject: [PATCH 25/36] Address comments

---
 include/tvm/topi/transform.h     |  8 -----
 python/tvm/relay/op/transform.py | 51 ++++++++++++++++++--------------
 python/tvm/topi/transform.py     | 51 ++++++++++++++++++--------------
 3 files changed, 56 insertions(+), 54 deletions(-)

diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index a9d5c7a360d..e0616a63a4a 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -1398,7 +1398,6 @@ inline Array<Tensor> meshgrid(const Array<Tensor>& inputs, const std::string& in
  *
  * \return A Tensor whose op member is the sparsereshape operation
  */
-
 inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& sparse_values,
                                    const Tensor& prev_shape, const Tensor& new_shape,
                                    const std::string name = "T_sparsereshape",
@@ -1448,13 +1447,6 @@ inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& s
               return new_sparse_indices[0];
             } else {
               ret = if_then_else(indices[1] == i, new_sparse_indices[i], ret);
-              if (const IntImmNode* op = ret.as<IntImmNode>()) {
-                if (op->value == -1) {
-                  continue;
-                } else {
-                  break;
-                }
-              }
             }
           }
           return ret;
diff --git a/python/tvm/relay/op/transform.py b/python/tvm/relay/op/transform.py
index 811863fe124..4a2ed579881 100644
--- a/python/tvm/relay/op/transform.py
+++ b/python/tvm/relay/op/transform.py
@@ -1328,39 +1328,44 @@ def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
 
     Parameters
     ----------
-    inputs : List[relay.Expr]
-        Input tensor and indices.
-        The first tensor is input data and rests are indices.
+    sparse_indices : relay.Expr
+        A 2-D tensor[N, n_dim] of integers containing location of sparse values, where N is the
+        number of sparse values and n_dim is the number of dimensions of the dense_shape
+    sparse_values : relay.Expr
+        A 1-D tensor[N] containing the sparse values for the sparse indices.
+    prev_shape : relay.Expr
+        A 1-D tensor containing the previous shape of the dense tensor
+    new_shape : relay.Expr
+        A 1-D tensor containing the new shape of the dense tensor
 
     Returns
     -------
     result: relay.Expr
         Output tensor.
     Examples
-        --------
-        .. code-block:: python
-
-            sparse_indices = [[0, 0, 0],
-                              [0, 0, 1],
-                              [0, 1, 0],
-                              [1, 0, 0],
-                              [1, 2, 3]]
+    --------
+    .. code-block:: python
 
-            sparse_values = [7, 5, 6, 3, 9]
+        sparse_indices = [[0, 0, 0],
+                            [0, 0, 1],
+                            [0, 1, 0],
+                            [1, 0, 0],
+                            [1, 2, 3]]
 
-            prev_shape = [2, 3, 4]
+        sparse_values = [7, 5, 6, 3, 9]
 
-            new_shape = [9, -1]
+        prev_shape = [2, 3, 4]
 
-            relay.sparsereshape(sparse_indices,
-                                sparse_values,
-                                prev_shape,
-                                new_shape)
-             =   [[0, 0],
-                  [0, 1],
-                  [1, 2],
-                  [4, 2],
-                  [8, 1]]
+        new_shape = [9, -1]
 
+        relay.sparsereshape(sparse_indices,
+                            sparse_values,
+                            prev_shape,
+                            new_shape)
+            =   [[0, 0],
+                [0, 1],
+                [1, 2],
+                [4, 2],
+                [8, 1]]
     """
     return _make.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)
diff --git a/python/tvm/topi/transform.py b/python/tvm/topi/transform.py
index 717b99e2251..9e0ff8b821a 100644
--- a/python/tvm/topi/transform.py
+++ b/python/tvm/topi/transform.py
@@ -939,39 +939,44 @@ def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
 
     Parameters
     ----------
-    inputs : List[relay.Expr]
-        Input tensor and indices.
-        The first tensor is input data and rests are indices.
+    sparse_indices : relay.Expr
+        A 2-D tensor[N, n_dim] of integers containing location of sparse values, where N is the
+        number of sparse values and n_dim is the number of dimensions of the dense_shape
+    sparse_values : relay.Expr
+        A 1-D tensor[N] containing the sparse values for the sparse indices.
+    prev_shape : relay.Expr
+        A 1-D tensor containing the previous shape of the dense tensor
+    new_shape : relay.Expr
+        A 1-D tensor containing the new shape of the dense tensor
 
     Returns
     -------
     result: relay.Expr
         Output tensor.
     Examples
-        --------
-        .. code-block:: python
-
-            sparse_indices = [[0, 0, 0],
-                              [0, 0, 1],
-                              [0, 1, 0],
-                              [1, 0, 0],
-                              [1, 2, 3]]
+    --------
+    .. code-block:: python
 
-            sparse_values = [7, 5, 6, 3, 9]
+        sparse_indices = [[0, 0, 0],
+                            [0, 0, 1],
+                            [0, 1, 0],
+                            [1, 0, 0],
+                            [1, 2, 3]]
 
-            prev_shape = [2, 3, 4]
+        sparse_values = [7, 5, 6, 3, 9]
 
-            new_shape = [9, -1]
+        prev_shape = [2, 3, 4]
 
-            relay.sparsereshape(sparse_indices,
-                                sparse_values,
-                                prev_shape,
-                                new_shape)
-             =   [[0, 0],
-                  [0, 1],
-                  [1, 2],
-                  [4, 2],
-                  [8, 1]]
+        new_shape = [9, -1]
 
+        relay.sparsereshape(sparse_indices,
+                            sparse_values,
+                            prev_shape,
+                            new_shape)
+            =   [[0, 0],
+                [0, 1],
+                [1, 2],
+                [4, 2],
+                [8, 1]]
     """
     return cpp.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)

From 5e08bcff6ad61219fafee51961128569e794ad7f Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Mon, 21 Dec 2020 12:24:01 +0000
Subject: [PATCH 26/36] Address PR COmments

---
 include/tvm/relay/attrs/transform.h  | 10 ++++++
 include/tvm/topi/transform.h         | 48 ++++++++++++++--------------
 src/relay/op/tensor/transform.cc     | 35 ++++++++++++--------
 tests/python/relay/test_op_level3.py | 20 ++++--------
 4 files changed, 63 insertions(+), 50 deletions(-)

diff --git a/include/tvm/relay/attrs/transform.h b/include/tvm/relay/attrs/transform.h
index cbe989f9355..8a984461587 100644
--- a/include/tvm/relay/attrs/transform.h
+++ b/include/tvm/relay/attrs/transform.h
@@ -401,6 +401,16 @@ struct SparseToDenseAttrs : public tvm::AttrsNode<SparseToDenseAttrs> {
   }
 };  // struct SparseToDenseAttrs
 
+/*! \brief Attributes used in sparsereshape operator */
+struct SparseReshapeAttrs : public tvm::AttrsNode<SparseReshapeAttrs> {
+  Array<Integer> prev_shape;
+  Array<Integer> new_shape;
+  TVM_DECLARE_ATTRS(SparseReshapeAttrs, "relay.attrs.SparseReshapeAttrs") {
+    TVM_ATTR_FIELD(prev_shape).describe("Previous shape of the dense output tensor");
+    TVM_ATTR_FIELD(new_shape).describe("New Shape of the dense output tensor");
+  }
+};  // struct SparseReshapeAttrs
+
 /*! \brief Attributes for ndarray_size operator */
 struct NdarraySizeAttrs : public tvm::AttrsNode<NdarraySizeAttrs> {
   DataType dtype;
diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index e0616a63a4a..eb52cb4ca1c 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -1399,30 +1399,30 @@ inline Array<Tensor> meshgrid(const Array<Tensor>& inputs, const std::string& in
  * \return A Tensor whose op member is the sparsereshape operation
  */
 inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& sparse_values,
-                                   const Tensor& prev_shape, const Tensor& new_shape,
+                                   Array<Integer> prev_shape, Array<Integer> new_shape,
                                    const std::string name = "T_sparsereshape",
                                    std::string tag = kInjective) {
   Array<Tensor> result;
-  Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0], new_shape->shape[0]};
-  std::vector<PrimExpr> multipliers(GetConstInt(prev_shape->shape[0]), 1);
-  std::vector<PrimExpr> dividers(GetConstInt(new_shape->shape[0]), 1);
-
-  tvm::te::compute(Array<PrimExpr>{1}, [&](const Array<Var>& indices) {
-    tvm::PrimExpr total_ele = prev_shape[0];
-    for (int i = GetConstInt(prev_shape->shape[0]) - 2; i >= 0; --i) {
-      multipliers[i] = prev_shape[i + 1] * multipliers[i + 1];
-      total_ele *= prev_shape[i + 1];
-    }
-    PrimExpr division_total_ele = 1;
-    for (int i = 0; i < GetConstInt(new_shape->shape[0]); ++i) {
-      division_total_ele *= if_then_else(new_shape[i] != -1, new_shape[i], 1);
-    }
-    for (int i = GetConstInt(new_shape->shape[0]) - 2; i >= 0; --i) {
-      dividers[i] = dividers[i + 1] * if_then_else(new_shape[i + 1] != -1, new_shape[i + 1],
-                                                   div(total_ele, division_total_ele));
-    }
-    return PrimExpr(1);
-  });
+  int new_shape_size = new_shape.size();
+  int prev_shape_size = prev_shape.size();
+  Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0], new_shape_size};
+  std::vector<PrimExpr> multipliers(prev_shape_size, 1);
+  std::vector<PrimExpr> dividers(new_shape_size, 1);
+
+  tvm::PrimExpr total_ele = prev_shape[0];
+  for (int i = prev_shape_size - 2; i >= 0; --i) {
+    multipliers[i] = prev_shape[i + 1] * multipliers[i + 1];
+    total_ele *= prev_shape[i + 1];
+  }
+  PrimExpr division_total_ele = 1;
+  for (int i = 0; i < new_shape_size; ++i) {
+    division_total_ele *= if_then_else(new_shape[i] != -1, new_shape[i], 1);
+  }
+  for (int i = new_shape_size - 2; i >= 0; --i) {
+    dividers[i] = dividers[i + 1] * if_then_else(new_shape[i + 1] != -1, new_shape[i + 1],
+                                                 div(total_ele, division_total_ele));
+  }
+
   result.push_back(compute(
       new_sparse_indices_shape,
       [&](const Array<Var>& indices) {
@@ -1435,14 +1435,14 @@ inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& s
           }
         }
         Array<PrimExpr> new_sparse_indices;
-        if (GetConstInt(new_shape->shape[0]) != 1) {
-          for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
+        if (new_shape_size != 1) {
+          for (int i = 0; i < new_shape_size; i++) {
             new_sparse_indices.push_back(floordiv(flattened_idx, dividers[i]));
             flattened_idx = floormod(flattened_idx, dividers[i]);
           }
           PrimExpr ret = -1;
 
-          for (int i = 0; i < GetConstInt(new_shape->shape[0]); i++) {
+          for (int i = 0; i < new_shape_size; i++) {
             if (indices.size() == 1) {
               return new_sparse_indices[0];
             } else {
diff --git a/src/relay/op/tensor/transform.cc b/src/relay/op/tensor/transform.cc
index 1089bd0835a..1298197f70b 100644
--- a/src/relay/op/tensor/transform.cc
+++ b/src/relay/op/tensor/transform.cc
@@ -1553,26 +1553,36 @@ RELAY_REGISTER_OP("meshgrid")
     .set_attr<FTVMCompute>("FTVMCompute", MeshgridCompute)
     .set_attr<TOpPattern>("TOpPattern", kInjective);
 
-bool SparseReshapeRel(const Array<Type>& types, int num_inputs, const Attrs& raw_attrs,
+TVM_REGISTER_NODE_TYPE(SparseReshapeAttrs);
+
+bool SparseReshapeRel(const Array<Type>& types, int num_inputs, const Attrs& attrs,
                       const TypeReporter& reporter) {
-  // types: [sparse_indices, sparse_values, prev_shape, new_shape, result]
-  ICHECK_EQ(types.size(), 5);
+  // types: [sparse_indices, sparse_values, result]
+  // ICHECK_EQ(types.size(), 3);
   auto sparse_indices = types[0].as<TensorTypeNode>();
-  auto new_shape = types[3].as<TensorTypeNode>();
-
-  Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0], new_shape->shape[0]};
-  reporter->Assign(types[4], TensorType(new_sparse_indices_shape, sparse_indices->dtype));
+  const auto* param = attrs.as<SparseReshapeAttrs>();
+  CHECK(param != nullptr);
+  Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0],
+                                           static_cast<int>((param->new_shape).size())};
+  reporter->Assign(types[2], TensorType(new_sparse_indices_shape, sparse_indices->dtype));
   return true;
 }
 
 Array<te::Tensor> SparseReshapeCompute(const Attrs& attrs, const Array<te::Tensor>& inputs,
                                        const Type& out_type) {
-  return {topi::SparseReshape(inputs[0], inputs[1], inputs[2], inputs[3])};
+  // ICHECK_EQ(inputs.size(), 2);
+  const auto* param = attrs.as<SparseReshapeAttrs>();
+  CHECK(param != nullptr);
+  return {topi::SparseReshape(inputs[0], inputs[1], param->prev_shape, param->new_shape)};
 }
 
-Expr MakeSparseReshape(Expr sparse_indices, Expr sparse_values, Expr prev_shape, Expr new_shape) {
+Expr MakeSparseReshape(Expr sparse_indices, Expr sparse_values, Array<Integer> prev_shape,
+                       Array<Integer> new_shape) {
+  auto attrs = make_object<SparseReshapeAttrs>();
+  attrs->prev_shape = std::move(prev_shape);
+  attrs->new_shape = std::move(new_shape);
   static const Op& op = Op::Get("sparsereshape");
-  return Call(op, {sparse_indices, sparse_values, prev_shape, new_shape}, Attrs(), {});
+  return Call(op, {sparse_indices, sparse_values}, Attrs(attrs), {});
 }
 
 TVM_REGISTER_GLOBAL("relay.op._make.sparsereshape").set_body_typed(MakeSparseReshape);
@@ -1580,11 +1590,10 @@ TVM_REGISTER_GLOBAL("relay.op._make.sparsereshape").set_body_typed(MakeSparseRes
 RELAY_REGISTER_OP("sparsereshape")
     .describe(R"code(Return twice of normal addition of two tensors.
 )code" TVM_ADD_FILELINE)
-    .set_num_inputs(4)
+    .set_num_inputs(2)
+    .set_attrs_type<SparseReshapeAttrs>()
     .add_argument("sparse_indices", "Tensor", "The first tensor")
     .add_argument("sparse_values", "Tensor", "The second tensor")
-    .add_argument("prev_shape", "Tensor", "The third tensor")
-    .add_argument("new_shape", "Tensor", "The fourth tensor")
     .add_type_rel("sparsereshape", SparseReshapeRel)
     .set_attr<TOpPattern>("TOpPattern", kInjective)
     .set_support_level(3)
diff --git a/tests/python/relay/test_op_level3.py b/tests/python/relay/test_op_level3.py
index b87301eba44..a0f7b4bfca6 100644
--- a/tests/python/relay/test_op_level3.py
+++ b/tests/python/relay/test_op_level3.py
@@ -1090,8 +1090,8 @@ def ref_sparsereshape(
     def verify_sparsereshape(
         sparse_indices_np: np.ndarray,
         sparse_values_np: np.ndarray,
-        dense_shape_np: np.ndarray,
-        default_value_np: np.ndarray,
+        prev_shape_np: np.ndarray,
+        new_shape_np: np.ndarray,
     ):
         """
         This function verifies the relay output of sparsereshape with its expected output.
@@ -1103,25 +1103,19 @@ def verify_sparsereshape(
         sparse_values = relay.var(
             "sparse_values", relay.TensorType(sparse_values_np.shape, str(sparse_values_np.dtype))
         )
-        dense_shape = relay.var(
-            "dense_shape", relay.TensorType(dense_shape_np.shape, str(dense_shape_np.dtype))
+        z = relay.op.sparsereshape(
+            sparse_indices, sparse_values, list(prev_shape_np), list(new_shape_np)
         )
-        default_value = relay.var(
-            "default_value", relay.TensorType(default_value_np.shape, str(default_value_np.dtype))
-        )
-        z = relay.op.sparsereshape(sparse_indices, sparse_values, dense_shape, default_value)
 
-        func = relay.Function([sparse_indices, sparse_values, dense_shape, default_value], z)
+        func = relay.Function([sparse_indices, sparse_values], z)
 
         ref_res = ref_sparsereshape(
-            sparse_indices_np, sparse_values_np, dense_shape_np, default_value_np
+            sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np
         )
         for target, ctx in tvm.testing.enabled_targets():
             for kind in ["graph", "debug"]:
                 intrp = relay.create_executor(kind, ctx=ctx, target=target)
-                op_res = intrp.evaluate(func)(
-                    sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np
-                )
+                op_res = intrp.evaluate(func)(sparse_indices_np, sparse_values_np)
                 tvm.testing.assert_allclose(op_res.asnumpy(), ref_res, rtol=1e-5, atol=1e-5)
 
     sparse_indices_np = np.array(

From 995455109c7a31664324d68891314cb7cef74bb5 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Tue, 22 Dec 2020 06:03:41 +0000
Subject: [PATCH 27/36] Change op Name to sparse_reshape

---
 include/tvm/relay/attrs/transform.h  |  2 +-
 include/tvm/topi/transform.h         |  6 +++---
 python/tvm/relay/op/_transform.py    |  2 +-
 python/tvm/relay/op/transform.py     |  6 +++---
 python/tvm/topi/transform.py         |  6 +++---
 src/relay/op/tensor/transform.cc     |  8 ++++----
 tests/python/relay/test_op_level3.py | 24 ++++++++++++------------
 7 files changed, 27 insertions(+), 27 deletions(-)

diff --git a/include/tvm/relay/attrs/transform.h b/include/tvm/relay/attrs/transform.h
index 8a984461587..06fa13a694b 100644
--- a/include/tvm/relay/attrs/transform.h
+++ b/include/tvm/relay/attrs/transform.h
@@ -401,7 +401,7 @@ struct SparseToDenseAttrs : public tvm::AttrsNode<SparseToDenseAttrs> {
   }
 };  // struct SparseToDenseAttrs
 
-/*! \brief Attributes used in sparsereshape operator */
+/*! \brief Attributes used in sparse_reshape operator */
 struct SparseReshapeAttrs : public tvm::AttrsNode<SparseReshapeAttrs> {
   Array<Integer> prev_shape;
   Array<Integer> new_shape;
diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index eb52cb4ca1c..c61f393c4b2 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -1387,7 +1387,7 @@ inline Array<Tensor> meshgrid(const Array<Tensor>& inputs, const std::string& in
 }
 
 /*!
- * \brief Compute new sparse indices and return them after the sparsereshape operation
+ * \brief Compute new sparse indices and return them after the sparse_reshape operation
  *
  * \param sparse_indices Indices where values of the dense tensor exist
  * \param sparse_values Values at the above indices respectively
@@ -1396,11 +1396,11 @@ inline Array<Tensor> meshgrid(const Array<Tensor>& inputs, const std::string& in
  * \param name The name of the operation
  * \param tag The tag to mark the operation
  *
- * \return A Tensor whose op member is the sparsereshape operation
+ * \return A Tensor whose op member is the sparse_reshape operation
  */
 inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& sparse_values,
                                    Array<Integer> prev_shape, Array<Integer> new_shape,
-                                   const std::string name = "T_sparsereshape",
+                                   const std::string name = "T_sparse_reshape",
                                    std::string tag = kInjective) {
   Array<Tensor> result;
   int new_shape_size = new_shape.size();
diff --git a/python/tvm/relay/op/_transform.py b/python/tvm/relay/op/_transform.py
index cd1dd0e381a..b54c6b3feb6 100644
--- a/python/tvm/relay/op/_transform.py
+++ b/python/tvm/relay/op/_transform.py
@@ -63,7 +63,7 @@
 _reg.register_injective_schedule("sparse_to_dense")
 _reg.register_injective_schedule("matrix_set_diag")
 _reg.register_injective_schedule("adv_index")
-_reg.register_injective_schedule("sparsereshape")
+_reg.register_injective_schedule("sparse_reshape")
 
 
 # concatenate
diff --git a/python/tvm/relay/op/transform.py b/python/tvm/relay/op/transform.py
index 4a2ed579881..ac7e873a6ad 100644
--- a/python/tvm/relay/op/transform.py
+++ b/python/tvm/relay/op/transform.py
@@ -1322,7 +1322,7 @@ def adv_index(inputs):
     return _make.adv_index(Tuple(inputs))
 
 
-def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
+def sparse_reshape(sparse_indices, sparse_values, prev_shape, new_shape):
     """
     Reshape a Sparse Tensor
 
@@ -1358,7 +1358,7 @@ def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
 
         new_shape = [9, -1]
 
-        relay.sparsereshape(sparse_indices,
+        relay.sparse_reshape(sparse_indices,
                             sparse_values,
                             prev_shape,
                             new_shape)
@@ -1368,4 +1368,4 @@ def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
                 [4, 2],
                 [8, 1]]
     """
-    return _make.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)
+    return _make.sparse_reshape(sparse_indices, sparse_values, prev_shape, new_shape)
diff --git a/python/tvm/topi/transform.py b/python/tvm/topi/transform.py
index 9e0ff8b821a..bda54635ec4 100644
--- a/python/tvm/topi/transform.py
+++ b/python/tvm/topi/transform.py
@@ -933,7 +933,7 @@ def adv_index(data, indices):
     return cpp.adv_index(data, indices)
 
 
-def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
+def sparse_reshape(sparse_indices, sparse_values, prev_shape, new_shape):
     """
     Reshape a Sparse Tensor
 
@@ -969,7 +969,7 @@ def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
 
         new_shape = [9, -1]
 
-        relay.sparsereshape(sparse_indices,
+        relay.sparse_reshape(sparse_indices,
                             sparse_values,
                             prev_shape,
                             new_shape)
@@ -979,4 +979,4 @@ def sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape):
                 [4, 2],
                 [8, 1]]
     """
-    return cpp.sparsereshape(sparse_indices, sparse_values, prev_shape, new_shape)
+    return cpp.sparse_reshape(sparse_indices, sparse_values, prev_shape, new_shape)
diff --git a/src/relay/op/tensor/transform.cc b/src/relay/op/tensor/transform.cc
index 1298197f70b..766ac03ccad 100644
--- a/src/relay/op/tensor/transform.cc
+++ b/src/relay/op/tensor/transform.cc
@@ -1581,20 +1581,20 @@ Expr MakeSparseReshape(Expr sparse_indices, Expr sparse_values, Array<Integer> p
   auto attrs = make_object<SparseReshapeAttrs>();
   attrs->prev_shape = std::move(prev_shape);
   attrs->new_shape = std::move(new_shape);
-  static const Op& op = Op::Get("sparsereshape");
+  static const Op& op = Op::Get("sparse_reshape");
   return Call(op, {sparse_indices, sparse_values}, Attrs(attrs), {});
 }
 
-TVM_REGISTER_GLOBAL("relay.op._make.sparsereshape").set_body_typed(MakeSparseReshape);
+TVM_REGISTER_GLOBAL("relay.op._make.sparse_reshape").set_body_typed(MakeSparseReshape);
 
-RELAY_REGISTER_OP("sparsereshape")
+RELAY_REGISTER_OP("sparse_reshape")
     .describe(R"code(Return twice of normal addition of two tensors.
 )code" TVM_ADD_FILELINE)
     .set_num_inputs(2)
     .set_attrs_type<SparseReshapeAttrs>()
     .add_argument("sparse_indices", "Tensor", "The first tensor")
     .add_argument("sparse_values", "Tensor", "The second tensor")
-    .add_type_rel("sparsereshape", SparseReshapeRel)
+    .add_type_rel("sparse_reshape", SparseReshapeRel)
     .set_attr<TOpPattern>("TOpPattern", kInjective)
     .set_support_level(3)
     .set_attr<FTVMCompute>("FTVMCompute", SparseReshapeCompute);
diff --git a/tests/python/relay/test_op_level3.py b/tests/python/relay/test_op_level3.py
index a0f7b4bfca6..5d0a90b6300 100644
--- a/tests/python/relay/test_op_level3.py
+++ b/tests/python/relay/test_op_level3.py
@@ -1043,8 +1043,8 @@ def verify_scatter_add(dshape, ishape, axis=0, dtype="float32"):
 
 
 @tvm.testing.uses_gpu
-def test_sparsereshape():
-    def ref_sparsereshape(
+def test_sparse_reshape():
+    def ref_sparse_reshape(
         sparse_indices: np.ndarray,
         sparse_values: np.ndarray,
         prev_shape: np.ndarray,
@@ -1087,14 +1087,14 @@ def ref_sparsereshape(
 
         return new_sparse_indices
 
-    def verify_sparsereshape(
+    def verify_sparse_reshape(
         sparse_indices_np: np.ndarray,
         sparse_values_np: np.ndarray,
         prev_shape_np: np.ndarray,
         new_shape_np: np.ndarray,
     ):
         """
-        This function verifies the relay output of sparsereshape with its expected output.
+        This function verifies the relay output of sparse_reshape with its expected output.
         """
         sparse_indices = relay.var(
             "sparse_indices",
@@ -1103,13 +1103,13 @@ def verify_sparsereshape(
         sparse_values = relay.var(
             "sparse_values", relay.TensorType(sparse_values_np.shape, str(sparse_values_np.dtype))
         )
-        z = relay.op.sparsereshape(
+        z = relay.op.sparse_reshape(
             sparse_indices, sparse_values, list(prev_shape_np), list(new_shape_np)
         )
 
         func = relay.Function([sparse_indices, sparse_values], z)
 
-        ref_res = ref_sparsereshape(
+        ref_res = ref_sparse_reshape(
             sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np
         )
         for target, ctx in tvm.testing.enabled_targets():
@@ -1124,7 +1124,7 @@ def verify_sparsereshape(
     sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
     prev_shape_np = np.array([2, 3, 6], dtype=np.int32)
     new_shape_np = np.array([9, 4], dtype=np.int32)
-    verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+    verify_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
 
     sparse_indices_np = np.array(
         [[0, 0, 0, 0], [0, 0, 1, 2], [0, 1, 0, 3], [1, 0, 0, 4], [1, 2, 3, 6]], dtype=np.int32
@@ -1132,25 +1132,25 @@ def verify_sparsereshape(
     sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
     prev_shape_np = np.array([2, 3, 6, 7], dtype=np.int32)
     new_shape_np = np.array([9, -1, 7], dtype=np.int32)
-    verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+    verify_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
 
     sparse_indices_np = np.array([[0, 0], [0, 1], [3, 4], [4, 3], [7, 3]], dtype=np.int32)
     sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
     prev_shape_np = np.array([9, 4], dtype=np.int32)
     new_shape_np = np.array([2, -1, 6], dtype=np.int32)
-    verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+    verify_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
 
     sparse_indices_np = np.array([[0, 0], [0, 1], [3, 4], [4, 3], [7, 3]], dtype=np.int32)
     sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
     prev_shape_np = np.array([9, 4], dtype=np.int32)
     new_shape_np = np.array([-1], dtype=np.int32)
-    verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+    verify_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
 
     sparse_indices_np = np.array([0, 5, 10, 20, 24], dtype=np.int32)
     sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
     prev_shape_np = np.array([25], dtype=np.int32)
     new_shape_np = np.array([5, 5], dtype=np.int32)
-    verify_sparsereshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
+    verify_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
 
 
 @tvm.testing.uses_gpu
@@ -1424,7 +1424,7 @@ def verify_adv_index(data_shape, index_shapes):
 
 
 if __name__ == "__main__":
-    test_sparsereshape()
+    test_sparse_reshape()
     test_cast()
     test_zeros_ones()
     test_unary_identity()

From 7508985db68eb70a90093c284a3f51ee92e60d85 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Tue, 22 Dec 2020 06:06:47 +0000
Subject: [PATCH 28/36] PR Comments

---
 src/relay/op/tensor/transform.cc | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/src/relay/op/tensor/transform.cc b/src/relay/op/tensor/transform.cc
index 766ac03ccad..b52008773a1 100644
--- a/src/relay/op/tensor/transform.cc
+++ b/src/relay/op/tensor/transform.cc
@@ -1558,10 +1558,10 @@ TVM_REGISTER_NODE_TYPE(SparseReshapeAttrs);
 bool SparseReshapeRel(const Array<Type>& types, int num_inputs, const Attrs& attrs,
                       const TypeReporter& reporter) {
   // types: [sparse_indices, sparse_values, result]
-  // ICHECK_EQ(types.size(), 3);
+  ICHECK_EQ(types.size(), 3) << "SparseReshapeRel expects 3 types but provided " << types.size();
   auto sparse_indices = types[0].as<TensorTypeNode>();
   const auto* param = attrs.as<SparseReshapeAttrs>();
-  CHECK(param != nullptr);
+  ICHECK(param != nullptr);
   Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0],
                                            static_cast<int>((param->new_shape).size())};
   reporter->Assign(types[2], TensorType(new_sparse_indices_shape, sparse_indices->dtype));
@@ -1570,9 +1570,10 @@ bool SparseReshapeRel(const Array<Type>& types, int num_inputs, const Attrs& att
 
 Array<te::Tensor> SparseReshapeCompute(const Attrs& attrs, const Array<te::Tensor>& inputs,
                                        const Type& out_type) {
-  // ICHECK_EQ(inputs.size(), 2);
+  ICHECK_EQ(inputs.size(), 2) << "SparseReshapeCompute expects 2 input but provided "
+                              << inputs.size();
   const auto* param = attrs.as<SparseReshapeAttrs>();
-  CHECK(param != nullptr);
+  ICHECK(param != nullptr);
   return {topi::SparseReshape(inputs[0], inputs[1], param->prev_shape, param->new_shape)};
 }
 
@@ -1588,7 +1589,7 @@ Expr MakeSparseReshape(Expr sparse_indices, Expr sparse_values, Array<Integer> p
 TVM_REGISTER_GLOBAL("relay.op._make.sparse_reshape").set_body_typed(MakeSparseReshape);
 
 RELAY_REGISTER_OP("sparse_reshape")
-    .describe(R"code(Return twice of normal addition of two tensors.
+    .describe(R"code(Return new sparse indices of the reshaped tensor
 )code" TVM_ADD_FILELINE)
     .set_num_inputs(2)
     .set_attrs_type<SparseReshapeAttrs>()

From ad500694b2f230c88b63b4e1066f63b9cc87e102 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Tue, 22 Dec 2020 11:00:08 +0000
Subject: [PATCH 29/36] Revert 3rd party

---
 3rdparty/vta-hw | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/3rdparty/vta-hw b/3rdparty/vta-hw
index 87ce9acfae5..57db5a718c7 160000
--- a/3rdparty/vta-hw
+++ b/3rdparty/vta-hw
@@ -1 +1 @@
-Subproject commit 87ce9acfae550d1a487746e9d06c2e250076e54c
+Subproject commit 57db5a718c74a788c98120ebbe1230797be698c8

From c1c50bcca881dc061e5fb8c618ed4a5a64de5181 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Tue, 29 Dec 2020 02:45:04 +0000
Subject: [PATCH 30/36] Add TF Frontend Code

---
 python/tvm/relay/frontend/tensorflow.py       | 21 +++++++
 .../frontend/tensorflow/test_forward.py       | 57 +++++++++++++++++++
 2 files changed, 78 insertions(+)

diff --git a/python/tvm/relay/frontend/tensorflow.py b/python/tvm/relay/frontend/tensorflow.py
index d5746a38582..b44b5c92c5e 100644
--- a/python/tvm/relay/frontend/tensorflow.py
+++ b/python/tvm/relay/frontend/tensorflow.py
@@ -975,6 +975,26 @@ def _impl(inputs, attr, params, mod):
     return _impl
 
 
+def _sparse_reshape():
+    def _impl(inputs, attr, params, mod):
+        assert len(inputs) == 3, "There should be 3 input tensors"
+
+        indices_tensor = _infer_value(inputs[0], params, mod).asnumpy()
+        values_tensor = np.zeros(indices_tensor.shape[0], dtype=indices_tensor.dtype)
+        prev_shape_tensor = _infer_value(inputs[1], params, mod).asnumpy()
+        new_shape_tensor = _infer_value(inputs[2], params, mod).asnumpy()
+
+        indices_data = _expr.const(indices_tensor, indices_tensor.dtype)
+        values_data = _expr.const(values_tensor, values_tensor.dtype)
+
+        ret = _op.sparse_reshape(
+            indices_data, values_data, list(prev_shape_tensor), list(new_shape_tensor)
+        )
+        return ret, _expr.const(new_shape_tensor, new_shape_tensor.dtype)
+
+    return _impl
+
+
 def _identity():
     def _impl(inputs, attr, params, mod):
         return inputs[0]
@@ -2423,6 +2443,7 @@ def _impl(inputs, attr, params, mod):
     "SpaceToDepth": _space_to_depth(),
     "SparseToDense": _sparse_to_dense(),
     "SparseTensorDenseMatMul": _sparse_tensor_dense_matmul(),
+    "SparseReshape": _sparse_reshape(),
     "Split": _split(False),
     "SplitV": _split(True),
     "Sqrt": AttrCvt("sqrt"),
diff --git a/tests/python/frontend/tensorflow/test_forward.py b/tests/python/frontend/tensorflow/test_forward.py
index 22ed6c5b2ed..ffec8352d38 100644
--- a/tests/python/frontend/tensorflow/test_forward.py
+++ b/tests/python/frontend/tensorflow/test_forward.py
@@ -1811,6 +1811,63 @@ def test_forward_sparse_dense_matmul():
     )
 
 
+#######################################################################
+# SparseReshape
+# ------------
+
+
+def _test_sparse_reshape(indices_np, values_np, prev_shape_np, new_shape_np, dtype):
+    with tf.Graph().as_default():
+        sp_input = tf.sparse.SparseTensor(
+            indices=indices_np, values=values_np, dense_shape=prev_shape_np
+        )
+        new_shape = tf.constant(new_shape_np, new_shape_np.dtype)
+        # new_shape = tf.placeholder(
+        #     shape=new_shape_np.shape, dtype=new_shape_np.dtype, name="new_shape"
+        # )
+
+        tf.sparse.reshape(sp_input, new_shape, name="sparse_reshape")
+
+        # import pdb
+
+        # pdb.set_trace()
+        compare_tf_with_tvm(
+            None,
+            "",
+            ["sparse_reshape:0", "sparse_reshape/Identity:0", "sparse_reshape:1"],
+        )
+
+
+def test_forward_sparse_reshape():
+    """ sparse_reshape op test"""
+    ###################################################################
+    #
+    # In order to create a SparseTensor, it requires 3 input as below:
+    #    SparseTensor(indices=[[0, 0], [1, 2]], values=[1, 2], dense_shape=[3, 4])
+    #
+    # Above Sparse can be represented in Dense as below :
+    #    [[1, 0, 0, 0]
+    #     [0, 0, 2, 0]
+    #     [0, 0, 0, 0]]
+    #
+    # ------------------------------------------------------------------
+    sparse_indices_np = np.array(
+        [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]], dtype=np.int32
+    )
+    sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    prev_shape_np = np.array([2, 3, 6], dtype=np.int32)
+    new_shape_np = np.array([9, 4], dtype=np.int32)
+
+    _test_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np, "int32")
+    sparse_indices_np = np.array(
+        [[0, 0, 0, 0], [0, 0, 1, 2], [0, 1, 0, 3], [1, 0, 0, 4], [1, 2, 3, 6]], dtype=np.int32
+    )
+    sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    prev_shape_np = np.array([2, 3, 6, 7], dtype=np.int32)
+    new_shape_np = np.array([9, -1, 7], dtype=np.int32)
+    _test_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np, "int32")
+
+
 #######################################################################
 # StridedSlice
 # ------------

From 6ad2e83b984fced6e8ff0d91c93edef17c9e5610 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Tue, 29 Dec 2020 06:03:18 +0000
Subject: [PATCH 31/36] Add TF Frontend stuff

---
 include/tvm/relay/attrs/transform.h           | 10 -----
 include/tvm/topi/transform.h                  | 45 +++++++++++--------
 python/tvm/relay/frontend/tensorflow.py       | 14 +++---
 python/tvm/relay/op/transform.py              |  5 +--
 python/tvm/topi/transform.py                  |  5 +--
 src/relay/op/tensor/transform.cc              | 38 +++++++---------
 .../frontend/tensorflow/test_forward.py       | 40 +++++++++++------
 tests/python/relay/test_op_level3.py          | 40 +++++++++--------
 8 files changed, 101 insertions(+), 96 deletions(-)

diff --git a/include/tvm/relay/attrs/transform.h b/include/tvm/relay/attrs/transform.h
index 06fa13a694b..cbe989f9355 100644
--- a/include/tvm/relay/attrs/transform.h
+++ b/include/tvm/relay/attrs/transform.h
@@ -401,16 +401,6 @@ struct SparseToDenseAttrs : public tvm::AttrsNode<SparseToDenseAttrs> {
   }
 };  // struct SparseToDenseAttrs
 
-/*! \brief Attributes used in sparse_reshape operator */
-struct SparseReshapeAttrs : public tvm::AttrsNode<SparseReshapeAttrs> {
-  Array<Integer> prev_shape;
-  Array<Integer> new_shape;
-  TVM_DECLARE_ATTRS(SparseReshapeAttrs, "relay.attrs.SparseReshapeAttrs") {
-    TVM_ATTR_FIELD(prev_shape).describe("Previous shape of the dense output tensor");
-    TVM_ATTR_FIELD(new_shape).describe("New Shape of the dense output tensor");
-  }
-};  // struct SparseReshapeAttrs
-
 /*! \brief Attributes for ndarray_size operator */
 struct NdarraySizeAttrs : public tvm::AttrsNode<NdarraySizeAttrs> {
   DataType dtype;
diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index c61f393c4b2..4975702b44d 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -1398,30 +1398,34 @@ inline Array<Tensor> meshgrid(const Array<Tensor>& inputs, const std::string& in
  *
  * \return A Tensor whose op member is the sparse_reshape operation
  */
-inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& sparse_values,
-                                   Array<Integer> prev_shape, Array<Integer> new_shape,
+inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& prev_shape,
+                                   const Tensor& new_shape,
                                    const std::string name = "T_sparse_reshape",
                                    std::string tag = kInjective) {
   Array<Tensor> result;
-  int new_shape_size = new_shape.size();
-  int prev_shape_size = prev_shape.size();
-  Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0], new_shape_size};
+  Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0], new_shape->shape[0]};
+
+  int new_shape_size = GetConstInt(new_shape->shape[0]);
+  int prev_shape_size = GetConstInt(prev_shape->shape[0]);
   std::vector<PrimExpr> multipliers(prev_shape_size, 1);
   std::vector<PrimExpr> dividers(new_shape_size, 1);
 
-  tvm::PrimExpr total_ele = prev_shape[0];
-  for (int i = prev_shape_size - 2; i >= 0; --i) {
-    multipliers[i] = prev_shape[i + 1] * multipliers[i + 1];
-    total_ele *= prev_shape[i + 1];
-  }
-  PrimExpr division_total_ele = 1;
-  for (int i = 0; i < new_shape_size; ++i) {
-    division_total_ele *= if_then_else(new_shape[i] != -1, new_shape[i], 1);
-  }
-  for (int i = new_shape_size - 2; i >= 0; --i) {
-    dividers[i] = dividers[i + 1] * if_then_else(new_shape[i + 1] != -1, new_shape[i + 1],
-                                                 div(total_ele, division_total_ele));
-  }
+  auto neg_shape_val = compute(Array<PrimExpr>{1}, [&](const Array<Var>& indices) {
+    tvm::PrimExpr total_ele = prev_shape[0];
+    for (int i = prev_shape_size - 2; i >= 0; --i) {
+      multipliers[i] = prev_shape[i + 1] * multipliers[i + 1];
+      total_ele *= prev_shape[i + 1];
+    }
+    PrimExpr division_total_ele = 1;
+    for (int i = 0; i < new_shape_size; ++i) {
+      division_total_ele *= if_then_else(new_shape[i] != -1, new_shape[i], 1);
+    }
+    for (int i = new_shape_size - 2; i >= 0; --i) {
+      dividers[i] = dividers[i + 1] * if_then_else(new_shape[i + 1] != -1, new_shape[i + 1],
+                                                   div(total_ele, division_total_ele));
+    }
+    return div(total_ele, division_total_ele);
+  });
 
   result.push_back(compute(
       new_sparse_indices_shape,
@@ -1455,6 +1459,11 @@ inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& s
         }
       },
       name, tag));
+  result.push_back(compute(Array<PrimExpr>{new_shape_size}, [&](const Array<Var>& indices) {
+    PrimExpr ret = new_shape(indices);
+    ret = if_then_else(ret == -1, neg_shape_val[0], ret);
+    return ret;
+  }, name, tag));
   return result;
 }  // namespace topi
 /*!
diff --git a/python/tvm/relay/frontend/tensorflow.py b/python/tvm/relay/frontend/tensorflow.py
index b44b5c92c5e..d3f5489bd33 100644
--- a/python/tvm/relay/frontend/tensorflow.py
+++ b/python/tvm/relay/frontend/tensorflow.py
@@ -980,17 +980,13 @@ def _impl(inputs, attr, params, mod):
         assert len(inputs) == 3, "There should be 3 input tensors"
 
         indices_tensor = _infer_value(inputs[0], params, mod).asnumpy()
-        values_tensor = np.zeros(indices_tensor.shape[0], dtype=indices_tensor.dtype)
+        values_tensor = params["SparseTensor/values"].asnumpy()
         prev_shape_tensor = _infer_value(inputs[1], params, mod).asnumpy()
-        new_shape_tensor = _infer_value(inputs[2], params, mod).asnumpy()
-
+        new_shape = inputs[2]
         indices_data = _expr.const(indices_tensor, indices_tensor.dtype)
-        values_data = _expr.const(values_tensor, values_tensor.dtype)
-
-        ret = _op.sparse_reshape(
-            indices_data, values_data, list(prev_shape_tensor), list(new_shape_tensor)
-        )
-        return ret, _expr.const(new_shape_tensor, new_shape_tensor.dtype)
+        prev_shape_data = _expr.const(prev_shape_tensor, prev_shape_tensor.dtype)
+        ret = _op.sparse_reshape(indices_data, prev_shape_data, new_shape).astuple()
+        return ret, _expr.const(values_tensor, values_tensor.dtype)
 
     return _impl
 
diff --git a/python/tvm/relay/op/transform.py b/python/tvm/relay/op/transform.py
index ac7e873a6ad..bb519f8fee2 100644
--- a/python/tvm/relay/op/transform.py
+++ b/python/tvm/relay/op/transform.py
@@ -1322,7 +1322,7 @@ def adv_index(inputs):
     return _make.adv_index(Tuple(inputs))
 
 
-def sparse_reshape(sparse_indices, sparse_values, prev_shape, new_shape):
+def sparse_reshape(sparse_indices, prev_shape, new_shape):
     """
     Reshape a Sparse Tensor
 
@@ -1359,7 +1359,6 @@ def sparse_reshape(sparse_indices, sparse_values, prev_shape, new_shape):
         new_shape = [9, -1]
 
         relay.sparse_reshape(sparse_indices,
-                            sparse_values,
                             prev_shape,
                             new_shape)
             =   [[0, 0],
@@ -1368,4 +1367,4 @@ def sparse_reshape(sparse_indices, sparse_values, prev_shape, new_shape):
                 [4, 2],
                 [8, 1]]
     """
-    return _make.sparse_reshape(sparse_indices, sparse_values, prev_shape, new_shape)
+    return TupleWrapper(_make.sparse_reshape(sparse_indices, prev_shape, new_shape), 2)
diff --git a/python/tvm/topi/transform.py b/python/tvm/topi/transform.py
index bda54635ec4..d4c21222cb4 100644
--- a/python/tvm/topi/transform.py
+++ b/python/tvm/topi/transform.py
@@ -933,7 +933,7 @@ def adv_index(data, indices):
     return cpp.adv_index(data, indices)
 
 
-def sparse_reshape(sparse_indices, sparse_values, prev_shape, new_shape):
+def sparse_reshape(sparse_indices, prev_shape, new_shape):
     """
     Reshape a Sparse Tensor
 
@@ -970,7 +970,6 @@ def sparse_reshape(sparse_indices, sparse_values, prev_shape, new_shape):
         new_shape = [9, -1]
 
         relay.sparse_reshape(sparse_indices,
-                            sparse_values,
                             prev_shape,
                             new_shape)
             =   [[0, 0],
@@ -979,4 +978,4 @@ def sparse_reshape(sparse_indices, sparse_values, prev_shape, new_shape):
                 [4, 2],
                 [8, 1]]
     """
-    return cpp.sparse_reshape(sparse_indices, sparse_values, prev_shape, new_shape)
+    return cpp.sparse_reshape(sparse_indices, prev_shape, new_shape)
diff --git a/src/relay/op/tensor/transform.cc b/src/relay/op/tensor/transform.cc
index b52008773a1..2d43805fa4e 100644
--- a/src/relay/op/tensor/transform.cc
+++ b/src/relay/op/tensor/transform.cc
@@ -1553,37 +1553,31 @@ RELAY_REGISTER_OP("meshgrid")
     .set_attr<FTVMCompute>("FTVMCompute", MeshgridCompute)
     .set_attr<TOpPattern>("TOpPattern", kInjective);
 
-TVM_REGISTER_NODE_TYPE(SparseReshapeAttrs);
-
 bool SparseReshapeRel(const Array<Type>& types, int num_inputs, const Attrs& attrs,
                       const TypeReporter& reporter) {
-  // types: [sparse_indices, sparse_values, result]
-  ICHECK_EQ(types.size(), 3) << "SparseReshapeRel expects 3 types but provided " << types.size();
+  // types: [sparse_indices, prev_shape, new_shape, result]
+  ICHECK_EQ(types.size(), 4) << "SparseReshapeRel expects 4 types but " << types.size()
+                             << " provided";
   auto sparse_indices = types[0].as<TensorTypeNode>();
-  const auto* param = attrs.as<SparseReshapeAttrs>();
-  ICHECK(param != nullptr);
-  Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0],
-                                           static_cast<int>((param->new_shape).size())};
-  reporter->Assign(types[2], TensorType(new_sparse_indices_shape, sparse_indices->dtype));
+  auto new_shape = types[2].as<TensorTypeNode>();
+  Array<PrimExpr> new_sparse_indices_shape{sparse_indices->shape[0], new_shape->shape[0]};
+  std::vector<Type> fields;
+  fields.push_back(TensorType(new_sparse_indices_shape, sparse_indices->dtype));
+  fields.push_back(TensorType(new_shape->shape, new_shape->dtype));
+  reporter->Assign(types[3], TupleType(Array<Type>(fields)));
   return true;
 }
 
 Array<te::Tensor> SparseReshapeCompute(const Attrs& attrs, const Array<te::Tensor>& inputs,
                                        const Type& out_type) {
-  ICHECK_EQ(inputs.size(), 2) << "SparseReshapeCompute expects 2 input but provided "
+  ICHECK_EQ(inputs.size(), 3) << "SparseReshapeCompute expects 2 input but provided "
                               << inputs.size();
-  const auto* param = attrs.as<SparseReshapeAttrs>();
-  ICHECK(param != nullptr);
-  return {topi::SparseReshape(inputs[0], inputs[1], param->prev_shape, param->new_shape)};
+  return {topi::SparseReshape(inputs[0], inputs[1], inputs[2])};
 }
 
-Expr MakeSparseReshape(Expr sparse_indices, Expr sparse_values, Array<Integer> prev_shape,
-                       Array<Integer> new_shape) {
-  auto attrs = make_object<SparseReshapeAttrs>();
-  attrs->prev_shape = std::move(prev_shape);
-  attrs->new_shape = std::move(new_shape);
+Expr MakeSparseReshape(Expr sparse_indices, Expr prev_shape, Expr new_shape) {
   static const Op& op = Op::Get("sparse_reshape");
-  return Call(op, {sparse_indices, sparse_values}, Attrs(attrs), {});
+  return Call(op, {sparse_indices, prev_shape, new_shape}, Attrs(), {});
 }
 
 TVM_REGISTER_GLOBAL("relay.op._make.sparse_reshape").set_body_typed(MakeSparseReshape);
@@ -1591,10 +1585,10 @@ TVM_REGISTER_GLOBAL("relay.op._make.sparse_reshape").set_body_typed(MakeSparseRe
 RELAY_REGISTER_OP("sparse_reshape")
     .describe(R"code(Return new sparse indices of the reshaped tensor
 )code" TVM_ADD_FILELINE)
-    .set_num_inputs(2)
-    .set_attrs_type<SparseReshapeAttrs>()
+    .set_num_inputs(3)
     .add_argument("sparse_indices", "Tensor", "The first tensor")
-    .add_argument("sparse_values", "Tensor", "The second tensor")
+    .add_argument("prev_shape", "Tensor", "The second tensor")
+    .add_argument("new_shape", "Tensor", "The third tensor")
     .add_type_rel("sparse_reshape", SparseReshapeRel)
     .set_attr<TOpPattern>("TOpPattern", kInjective)
     .set_support_level(3)
diff --git a/tests/python/frontend/tensorflow/test_forward.py b/tests/python/frontend/tensorflow/test_forward.py
index ffec8352d38..e42197faece 100644
--- a/tests/python/frontend/tensorflow/test_forward.py
+++ b/tests/python/frontend/tensorflow/test_forward.py
@@ -1821,20 +1821,15 @@ def _test_sparse_reshape(indices_np, values_np, prev_shape_np, new_shape_np, dty
         sp_input = tf.sparse.SparseTensor(
             indices=indices_np, values=values_np, dense_shape=prev_shape_np
         )
-        new_shape = tf.constant(new_shape_np, new_shape_np.dtype)
-        # new_shape = tf.placeholder(
-        #     shape=new_shape_np.shape, dtype=new_shape_np.dtype, name="new_shape"
-        # )
+        new_shape = tf.placeholder(
+            shape=new_shape_np.shape, dtype=new_shape_np.dtype, name="new_shape"
+        )
 
         tf.sparse.reshape(sp_input, new_shape, name="sparse_reshape")
-
-        # import pdb
-
-        # pdb.set_trace()
         compare_tf_with_tvm(
-            None,
-            "",
-            ["sparse_reshape:0", "sparse_reshape/Identity:0", "sparse_reshape:1"],
+            [new_shape_np],
+            [new_shape.name],
+            ["sparse_reshape:0", "sparse_reshape:1", "sparse_reshape/Identity:0"],
         )
 
 
@@ -1857,8 +1852,8 @@ def test_forward_sparse_reshape():
     sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
     prev_shape_np = np.array([2, 3, 6], dtype=np.int32)
     new_shape_np = np.array([9, 4], dtype=np.int32)
-
     _test_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np, "int32")
+
     sparse_indices_np = np.array(
         [[0, 0, 0, 0], [0, 0, 1, 2], [0, 1, 0, 3], [1, 0, 0, 4], [1, 2, 3, 6]], dtype=np.int32
     )
@@ -1867,6 +1862,24 @@ def test_forward_sparse_reshape():
     new_shape_np = np.array([9, -1, 7], dtype=np.int32)
     _test_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np, "int32")
 
+    sparse_indices_np = np.array([[0, 0], [0, 1], [3, 4], [4, 3], [7, 3]], dtype=np.int32)
+    sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    prev_shape_np = np.array([9, 4], dtype=np.int32)
+    new_shape_np = np.array([2, -1, 6], dtype=np.int32)
+    _test_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np, "int32")
+
+    sparse_indices_np = np.array([[0, 0], [0, 1], [3, 4], [4, 3], [7, 3]], dtype=np.int32)
+    sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    prev_shape_np = np.array([9, 4], dtype=np.int32)
+    new_shape_np = np.array([-1], dtype=np.int32)
+    _test_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np, "int32")
+
+    sparse_indices_np = np.array([[0], [5], [10], [20], [24]], dtype=np.int32)
+    sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
+    prev_shape_np = np.array([25], dtype=np.int32)
+    new_shape_np = np.array([5, 5], dtype=np.int32)
+    _test_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np, "int32")
+
 
 #######################################################################
 # StridedSlice
@@ -4739,4 +4752,5 @@ def lstm_cell():
 
 
 if __name__ == "__main__":
-    pytest.main([__file__])
+    test_forward_sparse_reshape()
+    # pytest.main([__file__])
diff --git a/tests/python/relay/test_op_level3.py b/tests/python/relay/test_op_level3.py
index 5d0a90b6300..8bce014e8bf 100644
--- a/tests/python/relay/test_op_level3.py
+++ b/tests/python/relay/test_op_level3.py
@@ -1046,7 +1046,6 @@ def verify_scatter_add(dshape, ishape, axis=0, dtype="float32"):
 def test_sparse_reshape():
     def ref_sparse_reshape(
         sparse_indices: np.ndarray,
-        sparse_values: np.ndarray,
         prev_shape: np.ndarray,
         new_shape: np.ndarray,
     ):
@@ -1054,7 +1053,7 @@ def ref_sparse_reshape(
         This function calculates the expected output of sparseshape operator given the inputs.
         """
         new_sparse_indices = np.ones(
-            (sparse_values.shape[0], new_shape.shape[0]), dtype=sparse_indices.dtype
+            (sparse_indices.shape[0], new_shape.shape[0]), dtype=sparse_indices.dtype
         )
         multipliers = np.ones(prev_shape.shape[0])
         dividers = np.ones(new_shape.shape[0])
@@ -1066,11 +1065,14 @@ def ref_sparse_reshape(
             division_total_ele *= new_shape[i]
         for i in range(prev_shape.shape[0] - 2, -1, -1):
             multipliers[i] = prev_shape[i + 1] * multipliers[i + 1]
+
+        for i in range(len(new_shape)):
+            if new_shape[i] == -1:
+                new_shape[i] = total_ele // division_total_ele
+
         for i in range(new_shape.shape[0] - 2, -1, -1):
-            if new_shape[i + 1] == -1:
-                dividers[i] = (total_ele // division_total_ele) * dividers[i + 1]
-            else:
-                dividers[i] = new_shape[i + 1] * dividers[i + 1]
+            dividers[i] = new_shape[i + 1] * dividers[i + 1]
+
         for row_num, sparse_row in enumerate(sparse_indices):
             flat_idx = 0
             if len(sparse_indices.shape) != 1:
@@ -1085,7 +1087,7 @@ def ref_sparse_reshape(
             else:
                 new_sparse_indices[row_num] = flat_idx
 
-        return new_sparse_indices
+        return new_sparse_indices, new_shape
 
     def verify_sparse_reshape(
         sparse_indices_np: np.ndarray,
@@ -1100,23 +1102,25 @@ def verify_sparse_reshape(
             "sparse_indices",
             relay.TensorType(sparse_indices_np.shape, str(sparse_indices_np.dtype)),
         )
-        sparse_values = relay.var(
-            "sparse_values", relay.TensorType(sparse_values_np.shape, str(sparse_values_np.dtype))
+        prev_shape = relay.var(
+            "prev_shape", relay.TensorType(prev_shape_np.shape, str(prev_shape_np.dtype))
         )
-        z = relay.op.sparse_reshape(
-            sparse_indices, sparse_values, list(prev_shape_np), list(new_shape_np)
+        new_shape = relay.var(
+            "new_shape", relay.TensorType(new_shape_np.shape, str(new_shape_np.dtype))
         )
+        z = relay.op.sparse_reshape(sparse_indices, prev_shape, new_shape).astuple()
 
-        func = relay.Function([sparse_indices, sparse_values], z)
+        func = relay.Function([sparse_indices, prev_shape, new_shape], z)
 
-        ref_res = ref_sparse_reshape(
-            sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np
-        )
+        ref_res = ref_sparse_reshape(sparse_indices_np, prev_shape_np, new_shape_np)
         for target, ctx in tvm.testing.enabled_targets():
             for kind in ["graph", "debug"]:
                 intrp = relay.create_executor(kind, ctx=ctx, target=target)
-                op_res = intrp.evaluate(func)(sparse_indices_np, sparse_values_np)
-                tvm.testing.assert_allclose(op_res.asnumpy(), ref_res, rtol=1e-5, atol=1e-5)
+                op_res = intrp.evaluate(func)(sparse_indices_np, prev_shape_np, new_shape_np)
+                for op_res_item, ref_res_item in zip(op_res, ref_res):
+                    tvm.testing.assert_allclose(
+                        op_res_item.asnumpy(), ref_res_item, rtol=1e-5, atol=1e-5
+                    )
 
     sparse_indices_np = np.array(
         [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]], dtype=np.int32
@@ -1146,7 +1150,7 @@ def verify_sparse_reshape(
     new_shape_np = np.array([-1], dtype=np.int32)
     verify_sparse_reshape(sparse_indices_np, sparse_values_np, prev_shape_np, new_shape_np)
 
-    sparse_indices_np = np.array([0, 5, 10, 20, 24], dtype=np.int32)
+    sparse_indices_np = np.array([[0], [5], [10], [20], [24]], dtype=np.int32)
     sparse_values_np = np.array([7, 5, 6, 3, 9], dtype=np.int32)
     prev_shape_np = np.array([25], dtype=np.int32)
     new_shape_np = np.array([5, 5], dtype=np.int32)

From 4b105c3b85333a60ca1e1e77badaecfe5a483866 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Tue, 29 Dec 2020 06:07:37 +0000
Subject: [PATCH 32/36] Docs

---
 python/tvm/relay/op/transform.py | 17 +++++++----------
 python/tvm/topi/transform.py     | 17 +++++++----------
 2 files changed, 14 insertions(+), 20 deletions(-)

diff --git a/python/tvm/relay/op/transform.py b/python/tvm/relay/op/transform.py
index bb519f8fee2..bf13951c2af 100644
--- a/python/tvm/relay/op/transform.py
+++ b/python/tvm/relay/op/transform.py
@@ -1331,8 +1331,6 @@ def sparse_reshape(sparse_indices, prev_shape, new_shape):
     sparse_indices : relay.Expr
         A 2-D tensor[N, n_dim] of integers containing location of sparse values, where N is the
         number of sparse values and n_dim is the number of dimensions of the dense_shape
-    sparse_values : relay.Expr
-        A 1-D tensor[N] containing the sparse values for the sparse indices.
     prev_shape : relay.Expr
         A 1-D tensor containing the previous shape of the dense tensor
     new_shape : relay.Expr
@@ -1352,19 +1350,18 @@ def sparse_reshape(sparse_indices, prev_shape, new_shape):
                             [1, 0, 0],
                             [1, 2, 3]]
 
-        sparse_values = [7, 5, 6, 3, 9]
-
         prev_shape = [2, 3, 4]
 
         new_shape = [9, -1]
 
-        relay.sparse_reshape(sparse_indices,
+        new_sparse_indices, new_shape = relay.sparse_reshape(sparse_indices,
                             prev_shape,
                             new_shape)
-            =   [[0, 0],
-                [0, 1],
-                [1, 2],
-                [4, 2],
-                [8, 1]]
+        new_sparse_indices = [[0, 0],
+                              [0, 1],
+                              [1, 2],
+                              [4, 2],
+                              [8, 1]]
+        new_shape = [9, 4]
     """
     return TupleWrapper(_make.sparse_reshape(sparse_indices, prev_shape, new_shape), 2)
diff --git a/python/tvm/topi/transform.py b/python/tvm/topi/transform.py
index d4c21222cb4..9f0daff079a 100644
--- a/python/tvm/topi/transform.py
+++ b/python/tvm/topi/transform.py
@@ -942,8 +942,6 @@ def sparse_reshape(sparse_indices, prev_shape, new_shape):
     sparse_indices : relay.Expr
         A 2-D tensor[N, n_dim] of integers containing location of sparse values, where N is the
         number of sparse values and n_dim is the number of dimensions of the dense_shape
-    sparse_values : relay.Expr
-        A 1-D tensor[N] containing the sparse values for the sparse indices.
     prev_shape : relay.Expr
         A 1-D tensor containing the previous shape of the dense tensor
     new_shape : relay.Expr
@@ -963,19 +961,18 @@ def sparse_reshape(sparse_indices, prev_shape, new_shape):
                             [1, 0, 0],
                             [1, 2, 3]]
 
-        sparse_values = [7, 5, 6, 3, 9]
-
         prev_shape = [2, 3, 4]
 
         new_shape = [9, -1]
 
-        relay.sparse_reshape(sparse_indices,
+        new_sparse_indices, new_shape = relay.sparse_reshape(sparse_indices,
                             prev_shape,
                             new_shape)
-            =   [[0, 0],
-                [0, 1],
-                [1, 2],
-                [4, 2],
-                [8, 1]]
+        new_sparse_indices = [[0, 0],
+                              [0, 1],
+                              [1, 2],
+                              [4, 2],
+                              [8, 1]]
+        new_shape = [9, 4]
     """
     return cpp.sparse_reshape(sparse_indices, prev_shape, new_shape)

From 3b47ba70db4ba387561c73d8d010891e7d5a69ad Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Tue, 29 Dec 2020 06:11:26 +0000
Subject: [PATCH 33/36] tests

---
 tests/python/frontend/tensorflow/test_forward.py | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/tests/python/frontend/tensorflow/test_forward.py b/tests/python/frontend/tensorflow/test_forward.py
index e42197faece..bf47d51b0c0 100644
--- a/tests/python/frontend/tensorflow/test_forward.py
+++ b/tests/python/frontend/tensorflow/test_forward.py
@@ -4752,5 +4752,4 @@ def lstm_cell():
 
 
 if __name__ == "__main__":
-    test_forward_sparse_reshape()
-    # pytest.main([__file__])
+    pytest.main([__file__])

From 3194b59f459fd67285b3f2af8fb32920200bea21 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Tue, 29 Dec 2020 06:12:55 +0000
Subject: [PATCH 34/36] clang format

---
 include/tvm/topi/transform.h | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index 4975702b44d..281359410d4 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -1459,11 +1459,14 @@ inline Array<Tensor> SparseReshape(const Tensor& sparse_indices, const Tensor& p
         }
       },
       name, tag));
-  result.push_back(compute(Array<PrimExpr>{new_shape_size}, [&](const Array<Var>& indices) {
-    PrimExpr ret = new_shape(indices);
-    ret = if_then_else(ret == -1, neg_shape_val[0], ret);
-    return ret;
-  }, name, tag));
+  result.push_back(compute(
+      Array<PrimExpr>{new_shape_size},
+      [&](const Array<Var>& indices) {
+        PrimExpr ret = new_shape(indices);
+        ret = if_then_else(ret == -1, neg_shape_val[0], ret);
+        return ret;
+      },
+      name, tag));
   return result;
 }  // namespace topi
 /*!

From 424b6fd480ff07ef7954bc3fbc20108c6d911429 Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@ip-172-31-27-149.us-east-2.compute.internal>
Date: Tue, 29 Dec 2020 06:27:14 +0000
Subject: [PATCH 35/36] brief;

---
 include/tvm/topi/transform.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/include/tvm/topi/transform.h b/include/tvm/topi/transform.h
index 281359410d4..56edb45f4a9 100644
--- a/include/tvm/topi/transform.h
+++ b/include/tvm/topi/transform.h
@@ -1390,7 +1390,6 @@ inline Array<Tensor> meshgrid(const Array<Tensor>& inputs, const std::string& in
  * \brief Compute new sparse indices and return them after the sparse_reshape operation
  *
  * \param sparse_indices Indices where values of the dense tensor exist
- * \param sparse_values Values at the above indices respectively
  * \param prev_shape Old Shape of the sparse tensor corresponding to sparse_indices
  * \param new_shape Desired Shape of the sparse tensor which will correspond to output
  * \param name The name of the operation
